<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>TCP_多路复用</title>
      <link href="/2019/01/15/TCP_%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2019/01/15/TCP_%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>TCP 多路复用是指：在一个 IP 链路中（比如本地计算机和亚马逊网站服务器），可以同时传递多个不同的 socket 配对数据段。这是因为每个唯一的TCP 连接由唯一的 <strong>[源 IP+源端口] — [目的 IP+目的端口]</strong>配对来表征，而在 TCP 包中含有这些信息，将多个不同配对的数据段一起通过链路发送至服务器端，在服务器端 TCP 会根据配对将数据段分配至相应的 socket来处理。  </p><p>客户端必须使用一个动态的端口号来向服务端请求服务，服务端的服务端口号根据应用层协议一般有 HTTP：80端口等约定，客户端的动态端口号一般大于等于1024，因为1023及以下的端口按约定作为服务器响应使用或其他特定用途，客户端请求只能使用1024及以上的端口号。 </p><p>服务器在收到数据包后，按照port 来找到绑定的服务程序来处理。</p><p><strong>注意</strong>：socket连接是一个逻辑概念，socket 一般是系统提供的在应用层与传输层之间的接口（可适用多个协议），应用层协议如 HTTP 通过 socket 和 TCP 协议来实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/1e622bb64614" target="_blank" rel="noopener">https://www.jianshu.com/p/1e622bb64614</a></p><p><a href="https://www.ccnahub.com/ip-fundamentals/understanding-tcp-and-udp-multiplexing/" target="_blank" rel="noopener">https://www.ccnahub.com/ip-fundamentals/understanding-tcp-and-udp-multiplexing/</a></p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP_流控制</title>
      <link href="/2019/01/15/TCP_%E6%B5%81%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/01/15/TCP_%E6%B5%81%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>流控制是指对传输数据的速率进行控制，通过使用流控制，作为接收端的计算机能够给出信号表示它还没有准备好接收接下来的数据。TCP 提供了一种使用“序列标号”作为确认信息的流控制机制。  </p><p>所有经过 TCP传输的数据段都会在插入进 TCP 包时打上“序列标号”，当接收方的计算机发送确认信息时，确认信息中包括下一个它准备接收的数据段的标号。</p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP_数据分段_数据段重组</title>
      <link href="/2019/01/15/TCP_%E6%95%B0%E6%8D%AE%E5%88%86%E6%AE%B5_%E6%95%B0%E6%8D%AE%E9%87%8D%E7%BB%84/"/>
      <url>/2019/01/15/TCP_%E6%95%B0%E6%8D%AE%E5%88%86%E6%AE%B5_%E6%95%B0%E6%8D%AE%E9%87%8D%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="TCP-segmentation-数据分段"><a href="#TCP-segmentation-数据分段" class="headerlink" title="TCP segmentation(数据分段)"></a>TCP segmentation(数据分段)</h2><p>数据分段是指将消息数据或数据流切分为更小的片段（“数据段”）的过程，TCP 从应用层接收消息数据，然后将其进行数据分段，这是为了能够将“数据段”放入 TCP 格式的数据字段中进行传输。  &lt;数据流：一系列的0-1所表示的数据&gt;</p><p>一旦数据段封装到 TCP 格式数据中，TCP 数据段和 TCP 头部然后传给 IP 层，将 TCP 数据段和 TCP 头部塞入 IP数据报的有效载荷中。  </p><p>通过数据分段，TCP生成了多个块数据，再将这些数据段各自分开的传输到目的端，对于在传输过程中损坏或丢失的数据段，可以进行重传到目的端。</p><h2 id="TCP-reassembly-重组"><a href="#TCP-reassembly-重组" class="headerlink" title="TCP reassembly(重组)"></a>TCP reassembly(重组)</h2><p>TCP 重组接收到的数据段为数据流，然后将该数据流传给应用层。例如：网页服务器取得网页数据，封装到 HTTP 头部，并将 编码的字符数据流传给 TCP，TCP 对字符数据流进行分段，然后通过 IP 协议经过网络链路传输到客户端；客户端收到 TCP 数据段后，进行重组为字符数据流，再将其发送给应用层，然后浏览器对其进行读入、渲染，形成可视化的网页。</p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP_数据传输</title>
      <link href="/2019/01/15/TCP_%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
      <url>/2019/01/15/TCP_%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
      <content type="html"><![CDATA[<p>一旦3次握手完成，那么双方的连接就建立好了，然后TCP 通知应用层开始传输数据传输和通信。  </p><p>TCP 按照以下步骤处理数据传输：</p><ol><li>TCP 将来自应用层协议（如 HTTP、SMTP、POP3）的消息进行“切断”为数据段(segments)；</li><li>TCP 然后传输数据段(segments)或称为消息碎片到远程主机；</li><li>TCP 在远程主机重组收到的数据段(segments)，尽管接收时顺序会乱，但数据段上都打上了“序列标签”，按照次序可完成重组。</li></ol><p>因为远程主机在每次收到数据段后都会发送 Acknowledges（确认信息）给发送者，所以 TCP 一直都知道当前的连接状态。</p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP_套接字</title>
      <link href="/2019/01/15/TCP_%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
      <url>/2019/01/15/TCP_%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>TCP套接字类似于电路中插座的概念，然而电路插座是一个物理组件，而这里指的是一个逻辑概念上的连接，由服务器主机创建，来与客户端程序的请求建立起连接。</p><p>TCP 套接字（或“虚拟端口”）在 TCP 和 UDP 中来表征唯一的端到端的连接，之所以被称为是“虚拟端口”，是因为一个物理连接器可以服务于多个连接。套接字的每一端使用自己的端口号，并且这个端口号在连接生命周期中不会改变。端口号和 IP 地址一起表征了一个端节点，两个端节点组成了一个 套接字（socket）。</p><h2 id="客户端-服务端-配对"><a href="#客户端-服务端-配对" class="headerlink" title="客户端-服务端 配对"></a>客户端-服务端 配对</h2><p>所有的 TCP 或 UDP 都有一个源和目的地，因此对于每个 socket 连接总是存在一个源端口和目的端口。</p><p>在 TCP 或 UDP头部信息中的一对字段（2个）用来记录在socket 连接过程中每一个端节点的源端口和目的地端口，头部信息中的该对字段中每个字段是16位宽，可表示0~65534的范围。每个计算机使用一个唯一的 IP 地址和唯一的（源端口，目的地端口）对来表征2台计算机之间特定的连接。典型的，当你的计算机连接到一个网站，那么计算机连接到目标网站服务器的80端口（对于 HTTP 协议的默认端口）；同时，在本机计算机中的端口是大于1024的，且不再被使用的端口，这意味着若1025、1026端口在被使用，而接着1025端口被释放，那么下一次1025将会被新的业务重新使用。</p><p>如今，为了应对黑客的攻击，本地计算机将随机的选择端口以让黑客不会预先知道。</p><p>服务器运行网络服务，而这些服务绑定在一个端口上，并监听这个端口。当多个客户端连接到相同的服务，多个客户端所使用的远程端口是一样的，因为在连接中源 IP 地址、端口号表征了唯一的一个客户端，因此对于同一个客户端而言，服务器也能追踪0~65534个不同连接。</p><p>注意，在 TCP 连接的范畴中，我们说一个端口何时是源端口还是目的端口，这取决于通信中哪一方正在传输信息，发出端就是客户端，接收端就是服务端。</p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP_面向连接的通信协议</title>
      <link href="/2019/01/15/TCP_%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/01/15/TCP_%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>面向连接的通信是指TCP 目的是建立与远程计算机的连接，TCP 保持着该连接的状态，因此它是可靠的通信协议。一个TCP 连接由 IP 地址、虚拟端口号来表征，而在数据传输过程中需要对数据段打上“序列标记”，以保证在接收端重组数据时不会出错。最大传输数据大小通过反馈机制来协商确定，这称为“窗口化”。  </p><p>IP 地址、虚拟端口号、窗口大小构成了一个连接或管道。例如，当你通过浏览器打开一个网站，正式建立了一个在浏览器与网站之间的TCP连接。你的本地计算机使用 IP 地址和虚拟端口号来表征自己；本地计算机建立一个连接，连接至网站 IP 地址和对应的端口（如 HTTP 所使用的80端口），然后在 TCP 连接的基础上进行数据的传输。  </p><p>TCP 使用3次握手来建立一个连接，注意尽管在3次握手过程中，双方都初始化了 TCP socket，但是还是有方向之分，客户端 -&gt; 服务端 开始3次握手 与 反方向是不一样的，因此3次握手是单向的。</p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP_头部信息</title>
      <link href="/2019/01/15/TCP_%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/01/15/TCP_%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<h2 id="TCP-header"><a href="#TCP-header" class="headerlink" title="TCP header"></a>TCP header</h2><p>TCP头部是 TCP 数据段的前24个字节，其包含了 TCP socket 的参数和状态，TCP头部用来跟踪双方通信的状态。因为TCP 数据段是插入在 IP 数据包的有效载荷中，因此在传输中TCP 头部紧跟着 IP 头。<br>TCP 并不关心通信双方的系统情况，它只要追踪双方的哪些 socket 是被打开的。IP 协议处理逻辑地址、路由、及主机与主机的连接。<br>TCP 在通信双方使用端口号来追踪连接节点，通过使用一些状态位，如 SYN、ACK、RST、FIN、sequence 号、acknowledgement 号来追踪双方数据传输的每一步通信。</p><p>TCP数据包图解：<br><img src="https://gitee.com/Pbright/Blogpics/raw/master/TCP数据包图解.png" alt="TCP数据包图解.png"></p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP_3次握手</title>
      <link href="/2019/01/15/TCP_3%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
      <url>/2019/01/15/TCP_3%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
      <content type="html"><![CDATA[<h2 id="TCP-的可靠性"><a href="#TCP-的可靠性" class="headerlink" title="TCP 的可靠性"></a>TCP 的可靠性</h2><p>TCP提供了一种数据段错误恢复机制，如数据段毁坏、重复、接收次序错乱，因此TCP 被称为是可靠协议。</p><p>数据段的次序通过在数据段中打上“序列标签”，这种序列标签使得 TCP 能够检测出丢失的数据段；同时，TCP 在传输数据后，需要对方给出“确认信号”来确认收到。</p><p>一般通过 CRC 校验码来检测数据段的，CRC 校验算法中加入了时间戳，在TCP 的每次跳转后都要重新进行 CRC 的验算，不符合结果的数据段将被丢弃。</p><h2 id="TCP-3次握手"><a href="#TCP-3次握手" class="headerlink" title="TCP 3次握手"></a>TCP 3次握手</h2><p>TCP 协议通过3次握手机制来建立 TCP/IP连接，可用 SYN–SYN+ACK–ACK 来表示。3次握手机制目的是双方协商出TCP socket 连接的参数，用以通过 SSH 或 HTTP 来传输数据。</p><p>设计3次握手机制也是为了双方能够在同一个时间点对各自的多个TCP socket做初始化和协商，这保证了唯一的物理网络接口，如以太网卡，能够同时传输多个 TCP 数据流。</p><p><img src="https://gitee.com/Pbright/Blogpics/raw/master/3次握手.png" alt="3次握手.png"></p><p>3次握手中通过不断的发送请求同步信号和确认信号，来保证数据包接收成功和在组装数据时数据包的顺序正确。</p><p>注意：UDP 是无连接的，这意味着UDP 不会像 TCP 这样去通过3次握手建立连接，UDP称为不可靠协议。这不是说 UDP 不能传输数据，只是不会进行双方的协商建立连接过程，UDP 只是传输然后期待数据传输成功。</p>]]></content>
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>那个我爱的人</title>
      <link href="/2018/12/02/%E6%88%91%E7%88%B1%E7%9A%84%E4%BA%BA/"/>
      <url>/2018/12/02/%E6%88%91%E7%88%B1%E7%9A%84%E4%BA%BA/</url>
      <content type="html"><![CDATA[<p><img src="https://gitee.com/Pbright/Blogpics/raw/master/love.png" alt="https://gitee.com/Pbright/Blogpics/raw/master/love.png"></p><h2 id="她"><a href="#她" class="headerlink" title="她"></a>她</h2><p>​        她在我心里从未变过，时隔8年，此刻还是那种心动的感觉。她身材娇小，和她部分刚烈的性格显得有些不符；她也会哭泣，惹人怜和心疼；她有灵性，时常有些新的点子，就像星光样忽闪忽闪；她会生气，会发脾气，会打你，可怎么都不会让你真正的去对她生气。对，这就是她，那个我爱的人。</p><p>​    我们相识于8年前，大一时我只是在人群中多看了她一眼就心动了，哈这句有点俗套（问号脸），可确实如此。那时的她脸上的笑容好美。</p><h2 id="我们"><a href="#我们" class="headerlink" title="我们"></a>我们</h2><h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><h2 id="毕业后"><a href="#毕业后" class="headerlink" title="毕业后"></a>毕业后</h2><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>我爱她。</p>]]></content>
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱情 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac 中搜索文件</title>
      <link href="/2018/11/29/Mac%20%E4%B8%AD%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6/"/>
      <url>/2018/11/29/Mac%20%E4%B8%AD%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="命令行-find-查找"><a href="#命令行-find-查找" class="headerlink" title="命令行 find 查找"></a>命令行 find 查找</h2><ul><li>指定找文件<br><code>find / -iname &quot;*.pdf&quot; -type f</code></li><li>指定找文件夹<br><code>find / -iname &quot;*.pdf&quot; -type d</code></li><li>通用查找<br><code>find . &quot;*&quot; | grep -P &quot;.jpg&quot;</code><br><code>find / -iname &quot;*.pdf&quot;</code></li><li>使用正则表达式查找,<code>-E</code>是扩展的正则查找<br><code>find -E . -regex &quot;.*.jpg&quot;</code></li></ul><h2 id="软件查找"><a href="#软件查找" class="headerlink" title="软件查找"></a>软件查找</h2><p><a href="https://www.devontechnologies.com/download/products.html" target="_blank" rel="noopener">Easyfind</a></p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learn Python Library </title>
      <link href="/2018/11/29/how-to-learn-python-library/"/>
      <url>/2018/11/29/how-to-learn-python-library/</url>
      <content type="html"><![CDATA[<p>How does one learns anything new? Remember the time when you learned to write, the time you learned to cycle, the time you learned to operate a computer etc. All of these learning have one thing in common: the ability of humans to recognize patterns.</p><p>Now coming to this specific question, first of all, a basic understanding of what the library does is important for diving deep into it.</p><p>Over the years I can sum up the way to learn python library into three steps:</p><p>help(library): The help method is a built-in python help system. It works in interactive mode. So, while developing python programs, fire up a python shell in a terminal and use help() method to get help on modules, functions or any python object.<br>For example, suppose you want to learn numpy(used for fast array computations) library Just type help(numpy) in python shell to get documentation on it.</p><p>An snippet of help on numpy package.</p><p><code>help(numpy)</code></p><p>Stackoverflow: Stackoverflow have tons of question and answers regarding python. It comes to rescue when examples and docstring from help() method is not sufficient or available. Ask for help about specific usecase like function parameters etc.<br>For example:</p><p><a href="https://stackoverflow.com/questions/48494581/converting-an-input-string-to-a-numpy-slice" target="_blank" rel="noopener">https://stackoverflow.com/questi…</a></p><p>Read Code: Last but the most used by great developers over the decades. Now to use it , one needs to know the file path in which specific class, method or module is written in.<br>Use python built-in inspect module to get the file path in an interactive shell first.</p><p>Important: This only works for modules or objects which are not built-in .</p><p><code>import inspect</code></p><blockquote><p>replace ‘name’ by appropriate method, module or class name</p></blockquote><p><code>inspect.getmodule(name).__file__</code></p><p>Once you have the file path , use any editor to open file and start reading the relevant lines.</p><blockquote><p><a href="https://www.quora.com/How-do-I-learn-a-python-library#" target="_blank" rel="noopener">https://www.quora.com/How-do-I-learn-a-python-library#</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Learn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac设置多个ssh-key</title>
      <link href="/2018/11/28/Mac%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/"/>
      <url>/2018/11/28/Mac%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/</url>
      <content type="html"><![CDATA[<p>需要给ssh配置多个key，不用名对应不同key文件。</p><ol><li><p>创建config文件<br>cd .ssh<br>touch config</p></li><li><p>创建ssh-key<br>ssh-keygen -t rsa -f ~/.ssh/id_rsa.别名 -C “邮箱地址“<br>示例</p><a id="more"></a></li></ol><p>ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“<br>ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“<br>ssh-key文件已经生成到指定路径了，那么接下来我们来配置一下。</p><ol start="3"><li><p>配置（仅供参考）</p><h1 id="second-user-xxx-xxx-com"><a href="#second-user-xxx-xxx-com" class="headerlink" title="second user(xxx@xxx.com)"></a>second user(<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>)</h1><h1 id="建一个github别名，新建的帐号使用这个别名做克隆和更新"><a href="#建一个github别名，新建的帐号使用这个别名做克隆和更新" class="headerlink" title="建一个github别名，新建的帐号使用这个别名做克隆和更新"></a>建一个github别名，新建的帐号使用这个别名做克隆和更新</h1><p>Host github<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa.github</p><p>second user(<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>)<br>建一个gitee别名，新建的帐号使用这个别名做克隆和更新<br>Host gitee<br>HostName gitee.com<br>User git<br>IdentityFile ~/.ssh/id_rsa.gitee<br>Host是别名。如果只是为了区分github、gitee等，为了方便使用，建议和HostName一致，这样在clone git的时候不用考虑修改hostname。<br>如果只是为了区分github、gitee等，</p></li></ol><ol start="4"><li>通过别名来使用<br>ssh -T gitee<br>返回：Welcome to Gitee.com, xxx!</li></ol><p>表示成功</p><p>ssh -T github<br>返回：Hi xinwen-mao! You’ve successfully authenticated, but GitHub does not provide shell access.<br>表示成功</p><p>参考：</p><p><a href="https://www.v2ex.com/t/342738" target="_blank" rel="noopener">https://www.v2ex.com/t/342738</a></p><p><a href="http://riny.net/2014/git-ssh-key/" target="_blank" rel="noopener">http://riny.net/2014/git-ssh-key/</a></p><p><a href="https://www.cnblogs.com/zichi/p/4704824.html" target="_blank" rel="noopener">https://www.cnblogs.com/zichi/p/4704824.html</a></p>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Iterm2快捷键</title>
      <link href="/2018/11/28/Iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/11/28/Iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>新建标签：command + t</p><p>关闭标签：command + w</p><p>切换标签：command + 数字 command + 左右方向键</p><p>切换全屏：command + enter</p><p>查找：command + f</p>  <a id="more"></a><h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><p>垂直分屏：command + d</p><p>水平分屏：command + shift + d</p><p>切换屏幕：command + option + 方向键 command + [ 或 command + ]</p><p>查看历史命令：command + ;</p><p>查看剪贴板历史：command + shift + h</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>清除当前行：ctrl + u</p><p>到行首：ctrl + a</p><p>到行尾：ctrl + e</p><p>前进后退：ctrl + f/b (相当于左右方向键)</p><p>上一条命令：ctrl + p</p><p>搜索命令历史：ctrl + r</p><p>删除当前光标的字符：ctrl + d</p><p>删除光标之前的字符：ctrl + h</p><p>删除光标之前的单词：ctrl + w</p><p>删除到文本末尾：ctrl + k</p><p>交换光标处文本：ctrl + t</p><p>清屏1：command + r</p><p>清屏2：ctrl + l</p>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pycharm 开发 Django——虚拟环境配置</title>
      <link href="/2018/06/08/pycharm%E5%BC%80%E5%8F%91django-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/06/08/pycharm%E5%BC%80%E5%8F%91django-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 后台开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Wireshark — 数据包分析</title>
      <link href="/2018/06/07/Wireshark%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/07/Wireshark%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h2><p>3个术语：帧、包、段。</p><p>一般一个数据包包含的信息如下：</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-06-07-072826.png" alt=""></p><ul><li>Frame：物理层的数据帧概况。</li><li>Ethernet II：数据链路层以太网帧头部信息。</li><li>Internet Protocol Version 4：互联网层IP包头部信息。</li><li>Transmission Control Protocol：传输层的数据段头部信息，此处是TCP协议。</li><li>Hypertext Transfer Protocol：应用层的信息，此处是HTTP协议。</li></ul><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><p><img src="/Users/pmz/Desktop/2018-06-07-073246.png" alt=""></p><h3 id="Ethernet-II"><a href="#Ethernet-II" class="headerlink" title="Ethernet II"></a>Ethernet II</h3><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-06-07-080608.png" alt=""></p><h3 id="Internet-Protocol-Version-4"><a href="#Internet-Protocol-Version-4" class="headerlink" title="Internet Protocol Version 4"></a>Internet Protocol Version 4</h3><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-06-07-080746.png" alt=""></p><h3 id="Transmission-Control-Protocol"><a href="#Transmission-Control-Protocol" class="headerlink" title="Transmission Control Protocol"></a>Transmission Control Protocol</h3><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-06-07-080809.png" alt=""></p><h3 id="Hypertext-Transfer-Protocol"><a href="#Hypertext-Transfer-Protocol" class="headerlink" title="Hypertext Transfer Protocol"></a>Hypertext Transfer Protocol</h3><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-06-07-080840.png" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/u/1585857/blog/479306" target="_blank" rel="noopener">https://my.oschina.net/u/1585857/blog/479306</a></p>]]></content>
      
      <categories>
          
          <category> 网络分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>客户端进入网络的隐私策略</title>
      <link href="/2018/06/07/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9A%90%E7%A7%81%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
      <url>/2018/06/07/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9A%90%E7%A7%81%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>转载：<a href="https://steemit.com/life/@iyouport/7nfymr" target="_blank" rel="noopener">https://steemit.com/life/@iyouport/7nfymr</a></p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-06-07-070150.png" alt=""></p><a id="more"></a><h2 id="谈谈即时聊天软件"><a href="#谈谈即时聊天软件" class="headerlink" title="谈谈即时聊天软件"></a>谈谈即时聊天软件</h2><p><strong>telegram</strong></p><p>最近出现的一些新闻再次推高了对 telegram 的讨论。我们不喜欢把地缘政治拉入技术领域的任何意见，但对于 telegram 不得不提醒一些细节问题。</p><p>任何使用手机注册的东西都会暴露广泛的元数据，不仅含有通过 Apple 和 Google 的消息传递服务的所有通知流，还有来自这些服务器的 IP 流量以及通讯应用服务器上的数据。这是 telegram 的诸多软肋之一。</p><p>当然这不是 telegram 所特有的，其他一些加密应用程序也是如此。政府的监视计划很明显会盯住这些弱点。即使政府没有利用这点，其产生的元数据仍然揭示了很多关于个人及其行为的信息，这些信息可以随时被任何目的所利用。</p><p>telegram将用户的联系人数据库上载到其服务器，由此便能够为所有用户建立一个巨大的社交网络图，以及他们如何相互认识的，如果你想运行的是一个秘密网络（不希望无关的人了解到这一群体的存在以及人们互相之间的关系）该应用的特点显然是一个令人担忧的状况。国安局一直拼命挖掘的就是这类信息，他们知道它有多高效。</p><p>简单说就是，将个人电话号码与服务链接的结果就好像在一边逃跑一边撒面包屑那样，追踪者会跟着面包屑的痕迹找到你本人。就算你使用的不是实名手机号也不能保证什么，对于能够访问电信系统的攻击者来说（例如SS7注入或全国电话运营商），劫持帐户的验证码非常简单。这种攻击方法最初是伊朗使用的，后来俄罗斯也被发现使用了同样的方法劫持帐户。显然，至少已经有一些国家正在使用这种技术来劫持账户。</p><p>telegram 增加了一个额外的安全功能来解决这种攻击 - 一个密码。如果为帐户设置了密码，在新设备上访问账户仅仅劫持手机验证码是不够的。</p><p>不过问题在于，所有非端到端加密聊天都会自动备份到 telegram 服务器 —— 该应用默认没有端对端加密，需要用户手动设置。当用户从另一台设备访问他们的帐户时，可以使用整个聊天历史记录。这是一个安全噩梦。存储敏感数据总是非常危险的。</p><p>telegram 的优势在于其频道功能，对于宣传的目的来说的确很高效，但是它的安全保障并没有人们想象中那么高不可攀。俄罗斯用户的抵抗运动所反对的是封锁和审查本身，并不是说应用的安全标准不够就可以对当局的封锁行为视而不见。当然这是最简单的常识无需啰嗦。</p><p>telegram 之所以被夸大，恐怕和恐怖组织的使用有关，不了解技术的用户会借此认为它是可靠的，毕竟恐怖组织比其他任何人都承受着更多来自国家民族的追捕。我们不知道 ISIS 为什么会信任该应用，但我们会倾向于推荐 Cryptocat 或 qTox 等，对于普通用户、异议人士和调查记者来说，是足够安全的。</p><p><strong>Cryptocat</strong> </p><p>Cryptocat 最开始是一个基于 Web 的网页即时通讯工具，其实就是一个浏览器扩展应用。2016年 Cryptocat 的开发者将其彻底改写成了桌面软件。并且支持 Windows、 Linux 和 Mac.</p><p>Cryptocat 是一款端对端即时通讯工具，Snowden 在躲避美国政府追捕过程中与记者联系使用就的就是 Cryptocat，这也是 Cryptocat 一举成名的原因之一。</p><p>其实早在 2014 年，EFF 就曾进行过一个“安全通訊評分表”项目，对目前主流的聊天软件就聊天加密、信息获取等七个方面做出评分，Cryptocat 获得了最高分。可见 Cryptocat 并非浪得虚名，其端到端的加密通讯技术，可以最大程度保证用户之间通讯信息的隐密性和安全性。</p><p>Cryptocat 的特点包括：多平台开源软件. 支持Windows、Linux和MAC；支持文字、图片、视频消息、文件分享；端对端加密，服务器不保存任何聊天信息；多设备支持，离线也能接收消息。</p><p>使用很简单，安装好客户端后在官网注册账号，不需要手机号。界面很简洁，没有一丝多余的设计。Cryptocat 支持发送文字、图片、音频、视频。不是视频聊天哦，而是通过摄像头录制一段小视频。</p><p>Cryptocat 也可以发送文件，不过速度不太好，当然这可能是因为 Cryptocat 没有中心服务器离线存储文件，所以分享文件速度较慢。</p><p>另外，Cryptocat 没有清理存聊天记录的功能，关闭聊天窗口将自动清除聊天记录，下次再打开聊天窗口，如果对方离线，会显示对方最近一次上线时间。</p><p>Cryptocat 不支持群聊功能，在其最开始的 Web 应用中是可以群聊的。群聊的安全性比较低，人越多越容易鱼龙混杂，当然最理想的还是把群聊当作可选性更好些，用户掌握主动权。</p><p><strong>qTox</strong></p><p>qTox 是一款基于 tox 制作的端对端加密即时通讯工具。tox 最早是在2013年6月23日由用户 irungentoo 发布并托管于 GitHub 上的，在此后的几年间 TOX 迅速发展，并衍生出许多基于 tox 制作的客户端，包括 qTox、µTox等等。</p><p>tox 最初的想法就是创建一个即时通讯工具，无需使用中央服务器即可运行，并且点对点，端到端加密，保证用户通信的保密性和安全性。tox 客户端较多，基本涵盖了所有平台。</p><p>随着政府监控项目的兴起，qTox 提供了一个易于使用的软件让用户能够在与亲人和朋友联系的时候防止他人的偷窥。当其它著名服务要求付费使用的时候，qTox 完全免费，并且没有广告。</p><p>qTox 特点：方便，支持文本、音频、视频通话；安全，点对点端对端加密，没有中心服务器；简单，qTox 使用简单，不需要任何专业知识，你只要专注于聊天；自由，qTox 是完全免费的。除了免费使用，还能自由修改它。</p><p>首先 qTox 是点对点通信，没有中心服务器，这就意味着使用 qTox 无需注册账号。下载客户端后直接运行，自动生成账号（76 位的十六进制字符），其实就是常见的一机一码。添加好友也很简单，复制对方的 76 位 ID 发送请求即可，添加成功后就可以愉快的进行聊天了。</p><p>qTox 支持语音和视频聊天，通话质量也不错，这点在体验上好过 Cryptocat。而且 qTox 还支持分组，而且支持群聊。</p><blockquote><p>注意，qTox 的群聊是一次性的，也就是说群聊成员下线重新登录后群聊就不存在了，你得重新添加群聊。我本人很赞同这种设计，有可能一些朋友觉得不方便，但要知道，一旦有人能在此过程中强迫群聊中其中一个人交出密码，所泄露的就是一群人。</p></blockquote><p>为什么建议不要使用以美国为基地的网络服务？</p><p>很多隐私专家一直强调，避免采用位于美国的网络服务。这是由于美国的监控项目使用了国家安全信件 (NSLs) 并伴随着不对外开放的法庭程序，其禁止收到 NSLs 的人谈论这份官方请求。这让政府可以秘密地强迫企业同意交出客户资料，从而把私人企业的网络服务转化成一种大规模监控的工具。（上面链接是 EFF 对此的介绍）</p><p>本文不做详细翻译了，普通用户了解大概意思就可以了。这件事非常重要，多年来不断有隐私专家对此强调，其中一个最典型的例子就是 Lavabit ，由 Ladar Levison 所创办。美国联邦调查局 FBI 发现 Snowden 使用其服务后，向 Lavabit 要求交出他的使用记录。当然 Lavabit 没有保留系统日志记录而邮件内容是经过加密后才储存，FBI 发出了（不公开法庭）的传票要取得 Lavabit 的 SSL 服务密钥。有了 SSL 密钥就可让他们取用 Lavabit 所有客户的通讯记录（包含元数据和未加密的邮件内容）而不只是 Snowden 的资料。</p><p>最后，Levison 交出了 SSL 密钥并在同时关闭了服务器。美国政府当时威胁要逮捕 Levison，认为他关闭 Lavabit 服务是“违反了法院命令”。</p><p>Ladar Levison 能做到这点，因为公司属于他一个人。如果它是一个有股东的公共公司，想象一下它的主要责任是为股东赚钱的疯狂的意识形态……这就是为什么隐私保护者一直警告小心硅谷，就算硅谷巨头有正义感，他们也做不到为了正义舍弃公司。</p><p>不仅是美国，还包括与美国共享情报的组织，从五眼到九眼到十四眼。</p><p>UKUSA 协议 是英国、美国、澳洲、加拿大与纽西兰五国之间的合作协议要共同来收集、分析和分享情报资讯。这个协议的成员就是五眼联盟， 聚焦在取得和分析来自全世界各地的情报。而这五眼国家同意彼此之间不如敌对国那样地互相监控, 由 Snowden 所揭露的资讯显示，有些五眼联盟成员会监控对方国家的人民并相互分享情报以规避国内法令约束不准监控自己国家的公民规定。五眼联盟也与其它不同的国家集团合作以分享情资 (其组成了九眼集团和十四眼集团等), 总之五眼国家和其它国家成员会对彼此互相进行情报监控。</p><h2 id="一些每个人都用得到的安全工具。"><a href="#一些每个人都用得到的安全工具。" class="headerlink" title="一些每个人都用得到的安全工具。"></a>一些每个人都用得到的安全工具。</h2><h3 id="相对安全的浏览器："><a href="#相对安全的浏览器：" class="headerlink" title="相对安全的浏览器："></a>相对安全的浏览器：</h3><p><strong>Mozilla Firefox</strong>：Firefox 是一个快速、可靠、开源且尊重用户隐私的上网工具。别忘了调整设置： WebRTC 以及 about:config 和安裝隐私保护附加组件。你可以在这里下载。</p><p><strong>Brave</strong>：比较新的开源浏览器”Brave” 会自动地封锁广告与追踪器，其效能比你目前所用的浏览器更为快速安全。Brave 为基于 Chromium 所开发的软件。在这里下载。</p><p><strong>Tor</strong> 浏览器：如果你需要额外的匿名层保护，则 Tor 浏览器就是最佳的选项。它是利用火狐浏览器作进一步的调配，其事先预设安装好了一些隐私保护的附加组件、加密与高级的代理器。在这里下载。</p><p>你正在使用的浏览器可能并不安全。当访问一个网站时，浏览器会自行地送出一些本身的设定资讯，例如有哪些字体可用，浏览器类型、安装的附加组件等。如果这些组合出来的资讯非常独特，很容易让其它人不需要 cookies 小程式就可以辨识与追踪你。EFF 创建过一个 Panopticlick 工具可以用来测试浏览器的独特程度 —— 浏览器指纹。</p><p>现代的网页浏览器并没有依照确保个人在互联网的隐私安全这一标准。如果很担心浏览器留下的独特特征指纹辨识，最实际的作法是使用免費的外挂软件像是 Privacy Badger、 uBlock Origin 与 Disconnect。 它们不只提供你网络自由，也保护你上网的隐私保护。建议进一步了解使用这些工具，会比试着操弄浏览器指纹更为容易和方便。</p><p><strong>Privacy Badger</strong> 可用来阻止广告商或其它第三方追踪器偷偷地追踪用户浏览哪些网站网页。当你浏览网站时 Privacy Badger 透过检查外部网站资源的请求了解追踪器状况。当用户浏览网站时，Privacy Badger 会检查外部的网站请求。请注意，Google Analytics 被 Privacy Badger 视为首先相关者（first-party），这表示如果你未用其它封锁器（例如 uBlock Origin），则 Google Analytics 就不会遭到封锁。 </p><p><strong>uBlock Origin</strong> 是一个有效的过滤器，容易在内存上执行，也比一般市面上的过滤器更可负载入上千个过滤器当中。这套软件并没有商业化的打算而且是完全开源。不只在火狐，也可以用在其它的浏览器如 Safari、Opera、Chromium 等等。不像 AdBlock Plus，uBlock 并没有所谓「可接受的广告」。 </p><p>Disconnect 可以自动移除储存在已开启分页中不需再用到的 cookies 以及其他用来监视用户的资讯都会被清除。 </p><ul><li>取消 WebRTC </li></ul><p>WebRTC 是一种新的通讯协议，其依靠 JavaScript 程序，可能會泄露 VPN 用户真实的 IP 地址资讯。有些软件如 NoScript 可以阻止这个漏洞，但还是建议直接关闭这个协议。</p><p>在火狐浏览器下取消 WebRTC：在 “about:config” 内，将 “media.peerconnection.enabled” 设为 “false”。</p><p>在浏览器的网址列輸入 “about:config” 并点击 enter 键；点击”I’ll be careful, I promise!”按钮；搜索”media.peerconnection.enabled”；双击这条资讯, “Value”栏位现在应该变成了”false”；完成。再作一次 WebRTC 漏洞测试</p><p>如果要确认每一个与 WebRTC 相关设置真的关闭了，可以再进行以下的设置改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>media.peerconnection.turn.disable = true</p><p>media.peerconnection.use_document_iceservers = false</p><p>media.peerconnection.video.enabled = false</p><p>media.peerconnection.identity.timeout = 1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决 Google Chrome 底下的 WebRTC 漏洞：Chrome 浏览器下无法完全取消 WebRTC，但可以透过扩展变更其路由设定（与防止洩漏）。有两种开源的方案为：WebRTC Leak Prevent（需依情况来调整设定选项）和  uBlock Origin （请选 “Prevent WebRTC from leaking local IP addresses”）。</p><p>苹果 iOS 操作系统下的 Chrome、Internet Explorer 与 Safari 目前尚未采用 WebRTC。但依旧推荐火狐浏览器。</p><h3 id="有隐私意识的电子邮件推荐"><a href="#有隐私意识的电子邮件推荐" class="headerlink" title="有隐私意识的电子邮件推荐"></a>有隐私意识的电子邮件推荐</h3><p>选择标准是：在美国境外营运，并且支持 SMTP TLS. </p><p><strong>Protonmail</strong>，瑞士，500MB，接受比特币，有自定网址；Disroot.org, 荷兰，4GB，接受比特币；Tuanota，德国，1GB；自定网址；Mailfence，比利时，500 MB，接受比特币，有自定网址；mailbox.org，德国，2GB，接受比特币，有自定网址；runbox，挪威，1 GB；startmail，荷兰，10 GB，接受比特币，有自定网址；KolabNow, 瑞士，2 GB，接受比特币。</p><p>另外，<strong>Mozilla Thunderbird</strong> 是一个免费、开源、跨平台的电邮、新闻与聊天软件，由 Mozilla 基金会开发维护。 Thunderbird 是电子邮件、新闻群组、新闻推送订阅与聊天 (支持 XMPP, IRC, Twitter) 的客户端软件；</p><p><strong>Claws Mail</strong> 是一个免费开源，使用 GTK 桌面环境为基础的电邮与新闻软件。它提供了简单的设定和丰富的功能，也包括 Windows 下的加密套件包。</p><p><strong>I2P-Bote</strong> 是一个完全去中心化的分布式电邮系统，不同的身份识别也不会曝露邮件表头资讯。到 2015 年为止，它仍处在测试版本，可以透过网页界面应用程序或 IMAP 与 SMTP 来取用。所有 bote-mails 电邮是采端对端透明加密或是可以选择利用传送者的私钥进行数字签名。操作系统：Windows, Mac, Linux, Android, F-Droid.</p><p><strong>Bitmessage</strong> 是一种点对点的通讯协议，被用来传送加密讯息给单一或多名订阅者。它是去中心化与无信任，指的是用户不必要信任任何根凭证授权的实体。它采用强度高的认证授权，让送件者的讯息无法被欺骗，目的在于能将非讯息内容的资料予以隐藏。操作系统：Windows, Mac, Linux.</p><p><strong>Retroshare</strong> 可建立朋友间的加密通讯连线，没有人可以监控你。 Retroshare 是一个完全分散化的设计，这代表着它没有任何中心控制的服务器。它完全开源和免费。没有任何成本、广告或是服务协议。操作系统：Windows, Mac, Linux。</p><h3 id="重视用户隐私的搜索引擎"><a href="#重视用户隐私的搜索引擎" class="headerlink" title="重视用户隐私的搜索引擎"></a>重视用户隐私的搜索引擎</h3><p>如果你目前仍在使用 Google、 Bing 或 Yahoo 等搜寻引撃，那么必须说，它们都非常不安全。你应该换成以下这些搜索引擎：</p><p><a href="https://searx.me/" target="_blank" rel="noopener"><strong>searx</strong></a> 开源搜索引擎，综合来自其它搜索引擎的查询结果但不会储存用户的资讯，不留活动记录、无广告也不会追踪。</p><p><a href="https://www.startpage.com/" target="_blank" rel="noopener"><strong>StartPage</strong></a> 是 Google 搜索引擎的查询结果，但有完全的隐私保护措施。StartPage 是一家欧洲公司，自 2006 年起就很重视隐私。</p><p><a href="https://duckduckgo.com" target="_blank" rel="noopener"><strong>DuckDuckGo</strong></a> 不会追踪用户的搜索引擎。 Some of DuckDuckGo　部份的代码是放在 GitHub 的免费软件，但其核心是封闭。公司在美国，但跟华盛顿无关，它是个特例，就像 EFF 那样。</p><h3 id="安全档案分享"><a href="#安全档案分享" class="headerlink" title="安全档案分享"></a>安全档案分享</h3><p><strong>OnionShare</strong> 是一套开源工具，可以安全而匿名地分享档案，没有大小限制。它透过网页服务器来启动，让自身变成 Tor 洋䓤服务接取的一部份，产生一个无法猜測的网址以用來接取和下载档案。其并不需要在互联网上设定一个服务器或是使用第三方的档案分享服务。用戶可以透过自己的电脑來放置这些档案，再使用 Tor 以让档案可以透过互联网暂时被存取。操作系统： Windows、Mac、Linux.</p><p><strong>Magic Wormhole</strong> 让电脑之间安全地收取档案资料。这个套件提供一个名为虫洞 wormhole 的资料库，其可以在电脑之间取用不限大小的档案与目录资料夹。其电脑间两个终端利用一致虫洞代码 “wormhole codes”　来识别，一般而言，传送端的电脑会产生与显示这个代码，而接收端电脑则必须输入此代码以进行连接。 此代码很简短且人类可识读，利用发音可区别的文字行。接收端的电脑则在代码字上提供完成分页，因此通常要输入一些字元。虫洞代码仅能使用一次，故不必强记。跨平台。</p><p>安全的档案同步软件</p><p><strong>SparkleShare</strong> 在自己的电脑上建立一个特别的资料夹，用户可把远端主机的资料夹（或专案）存放到这个资料夹底下。这些专案会保持自动与主机以及其它的加入的资料夹同群一起更新档案，新增、移除或编辑等最新状态。操作系统：Windows, Mac, Linux.</p><p><strong>Syncany</strong> 可让用户备份与分享工作站上的某些资料夹，它是一个开源的软件且提供资料加密功能，对储存类型与供给上提供了很大的弹性。档案在上传到主机前会先经过加密手续。操作系统： Windows, Mac, Linux.</p><p><strong>Syncthing</strong> 用来替换商用同步软件与云端服务，它开放、值得信任且去中心化。你的资料就是你的资料，当事人有权选择它要存放在哪里，是否要与其它第三者分享以及资料如何在网络上被传递。操作系统：Windows, Mac, Linux, Android, BSD, Solaris.</p><h3 id="档案加密系统"><a href="#档案加密系统" class="headerlink" title="档案加密系统"></a>档案加密系统</h3><p>如果你尚未对使用中的硬盘、电子邮件或档案库予以加密，你应该赶快从这挑选一个加密软件。</p><p><strong>VeraCrypt</strong> - 硬盘加密 可取得源代码的免费软件工具，用来进行快速加密。它可以为一个档案建立一个虚拟的加密硬盘、加密分区或是在开机前授权设置整个设备的硬盘都予以加密。 VeraCrypt 源自目前已无进展的 TrueCrypt 专案。它最初的发布是 2013 年 6 月 23 日。据开发者表示，原本 TrueCrypt 源代码在审查后发现的问题已经解决，大幅地改善了安全性。操作系统：Windows, Mac, Linux.</p><p><strong>GNU Privacy Guard</strong> - 电邮加密 GnuPG 是采用 GPL 授权，替代 PGP 密码学软件套件。 GnuPG 可兼容 RFC 4880, 它是一个目前 IETF OpenPGP 标准轨道规格。目前 PGP (以及Veridis’ Filecrypt)的版本可以和 GnuPG 以及其它 OpenPGP 兼容系统交互操作。 GnuPG 是自由软件基金会GNU 软件专案中的一部份，曾接受德国政府的经费赞助。 操作系统：Windows, Mac, Linux, Android, BSD.</p><p><strong>PeaZip</strong> - 档案库加密 PeaZip 是由 Giorgio Tani 所开发的一套免费开源的档案管理与档案库软件。它支援原生的 PEA 档案库格式(特色为压缩、多组磁区分割、弹性化节授权加密和一致的检验格式)以及其它的主流格式。其特别关注在开放格式，目前有支持 181 档案延伸格式。操作系统： Windows, Linux, BSD.</p><h3 id="去中心的社交网络"><a href="#去中心的社交网络" class="headerlink" title="去中心的社交网络"></a>去中心的社交网络</h3><p>如果你还在使用如 Facebook, Twitter 或 Google 的社交网站，这些都是集中化的东西，你无法摆脱审查和隐私侵犯。建议从以下挑选替代品。</p><p><strong>diaspora</strong> 基于三大核心哲学：去中心化、自由和隐私。它希望能引起大家关切由中心所控制社交网站下的隐私问题，所以可以让用户自行架设服务器（或称”pod”）来控制内容，而各个服务器可以再自行互动分享动态更新、照片或其它的资料。</p><p><strong>Friendica</strong> 强调在隐私控制上的仔细设置，它是一个容易安装在服务器上的软件，以期待尽可能出现更多其它的社交网络联邦。 Friendica 用户可以从 Facebook, Twitter, Diaspora, GNU social，App.net, Pump.io 等等多项社交网络服务来整合其联系人的名单到自己的社交时间流。</p><p><strong>GNU social</strong> 的功能有点类似推特，但希望能为微博客社群，提供更开放、互相扶持的分散式沟通功能。企业或个人可以自行安装 GNU social 在自家机器上，以控管自己的服务与资料数据。著名的公共网站如： quitter.se 和 gnusocial.no.</p><h3 id="安全的网络笔记应用"><a href="#安全的网络笔记应用" class="headerlink" title="安全的网络笔记应用"></a>安全的网络笔记应用</h3><p>如果你仍然在使用如 Evernote、Google Keep 或 Microsoft OneNote，赶紧换掉它们。</p><p><strong>Laverna</strong> 以 JavaScript 开发的网页笔记应用程式，它支持 Markdown 语法编辑和加密功能。这个应用程序将笔记储存在浏览器的资料库上，只有你能取用，所以既安全又能保护隐私。操作系统：Windows, Mac, Linux, 网页。</p><p><strong>Turtl</strong> 可以做笔记、网址书签和储存敏感专案的文件。它可让工作伙伴共享密码,追踪你所写的文章。 Turtl 让文件保持安全,只有你和有分享权限者可以看到。操作系统：Windows, Mac, Linux, Android.</p><p><strong>Standard Notes</strong> 是一个简单私密的笔记应用程序，可以轻松、随时随地作笔记。它的功能包括了每个平台上端点对端点之间的加密，而其桌面应用则有丰富的主題模版和客制化编辑器。操作系统：Windows, Mac, Linux, iOS, Android, Web.</p><h3 id="安全的生产力工具"><a href="#安全的生产力工具" class="headerlink" title="安全的生产力工具"></a>安全的生产力工具</h3><p><strong>Etherpad</strong> 是一个可以高度自定义的开源在线编辑器，它提供了即时的协同编辑功能。 Etherpad 可以让你即时地在线上协力编写文件，在你的浏览器上就像是有多名参与者共同在编写一份文章、发布消息或是任务清单等等功能。操作系统：Windows, Mac, Linux.</p><p><strong>EtherCalc</strong> 是一个网页版的试算表，其资料存在网页上，使用者可以同一时间在同一个档案上进行编辑而其变动会立即呈现在屏幕上。它可用来作为共享的库存统计、问卷表单、清单管理、脑力激荡等工具。操作系统：Windows, Mac, GNU/Linux, FreeBSD, Browser.</p><p><strong>ProtectedText</strong> 是一开源的网页应用程序，它可以在浏览器上加密与解密文字档案而其密码(或称其杂凑值)绝不会送回到服务器。 - 因此若密钥和密码则文字内容无法被解密，就算有关当局拿到文档也没用。它无 cookies, 无时限，不用注册也不会对用户进行追踪。支持各式浏览器。</p><h3 id="安全电脑操作系统"><a href="#安全电脑操作系统" class="headerlink" title="安全电脑操作系统"></a>安全电脑操作系统</h3><p>如果你目前还在使用微软 Windows 或是苹果电脑 OS X 的操作系统，或许该考虑其它替代选项了。</p><p><strong>Qubes</strong> 是一个开源的操作系统，其设计为桌面型电脑提供更坚强的安全保护。 Qubes 是以 Xen 为基础, X 视窗系统桌面环境与 Linux,它可以执行大多数的 Linux 应用程序以及适用大部份的 Linux 的硬件效能驱动。</p><p><strong>Debian</strong> 有点像 Unix 的电脑操作系统，它是 Linux 的发布版本之一，其由自由免费的软件所组成，大部份的软件都是采用 GNU 一般公共授权。有一群人长期地投入 Debian 专案的开发维护。</p><hr><p>⚠️为什么 Windows 10 是隐私噩梦？</p><p>因为1、系统会默认预设为启用资料同步：浏览网络记录与打开的网站；应用程序设定；WiFi 热点名称和密码。2、你的机子被预设标记了一个独一的广告识别码：用它第三方广告商或网络商可对你进行个性化广告服务。3、Cortana 可以收集你的任何资料：键盘记录，搜索与麦克风输入；日历资料；聆听什么音乐；信用卡资讯；购买行为。4、微软可以收集任何个人资料：用户身份识别；密码；人种族群资讯；兴趣与习惯；使用数据；联系人与人际关系；地点地理资讯；电子邮件、即时通讯的内容、通话记录与声音影像记录。5、你的资料可能被他人使用：下载 Windows 10 时,你授予了微软公司可以将上述资料分享给第三者，不管有无取得你的同意。</p><p>你也可以下载这个工具 W10Privacy，利用一些已知的方式来设法禁用 Windows 10 下主要的追踪监控功能。以及另一些应对方法。</p><p>美国国安局建立了一套设施，其几乎可以拦截任何通讯。这套设备的能力，大多数人类的通讯都会自动地被吸纳进去而不是针对特定目标。如果我想要看你的电邮内容或是你老婆的电话，我只须要利用这套设备进行拦截，就可以取得你的电子邮件、密码、电信通话记录、信用卡资料等等。我不想活在一个做这种勾当的社会里，我不想要活在一个任何所做的事所说的话都被记录下来的世界。这不是我愿意去支持或是存活下来的地方。<br>—— Edward Snowden in The Guardian<br>我们都需要有地方可以去探索而不依靠别人施加在我们身上的眼光，只有在一个不必被放大检视的地方我们才可以真正地测试出自己的极限。真正的私域才能允许不同声音、创造力和个人试探式的谎言。<br>—— Glenn Greenwald in Huffington Post<br>开源的路由器固件</p><hr><p><strong>OpenWrt</strong> 是一套利用 Linux 核心的操作系统 (特别是一种「嵌入式」操作系统)，主要用于一些路由网络流量的设备上。它主要的构成是由 Linux 核心, util-linux、uClibc 和 BusyBox。这些元素都已经过尺寸的最佳调适，以符合家用路由器这类的小型设备与其有限的内存容量与储存空间。</p><p><strong>pfSense</strong> 是利用 FreeBSD 所开发的一套用于防火墙/路由器上的开源固件。它安装在电脑上可变成网路上防火墙/路由器功能，并以其可靠与不输给商用软件的强大功能而著称。 pfSense 通常布署在周边的防火墙、路由器、无线接取器、DHCP 服务器, DNS 服务器, 以及 VPN 末端点。</p><p><strong>LibreWRT </strong>是一套以 GNU/Linux-libre 授权的发布版本，利用最小的资源装置在电脑上，例如 Ben Nanonote，利用 ath9k 的无线路由器以及其它强调尊重用户自由与免费软件的硬件设备上。自由软件基金会即在其接取器和路由器上安装 LibreWRTIt，以提供办公室内移动电脑设备的网络连线。</p>]]></content>
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络隐私保护 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MacOS 日常使用 Issue</title>
      <link href="/2018/06/05/MacOS%20%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/05/MacOS%20%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h2><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><ul><li>MacOS上的 Chrome CPU占有率很高时, 可以通过 Chrome 的<code>Setting</code> -&gt; <code>Tools</code> -&gt; <code>Task Manager</code> 查看是什么插件占用了 CPU.<a id="more"></a></li></ul>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统-8章</title>
      <link href="/2018/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8%E7%AB%A0/"/>
      <url>/2018/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><h3 id="1-进程锁"><a href="#1-进程锁" class="headerlink" title="1. 进程锁"></a>1. 进程锁</h3><h4 id="什么是线程竞争"><a href="#什么是线程竞争" class="headerlink" title="什么是线程竞争"></a>什么是线程竞争</h4><p>线程竞争(Threads Contention): 本质上是多个线程同时又想占用某个共享资源的趋势。竞争中的线程的速度比单线程要低。这有多重意义：</p><ul><li><p>有锁必然有竞争。通常的竞争是指一个线程必须等待一个被占用的资源释放后才能继续，这就降低了此线程的速度。</p><a id="more"></a></li><li>没有锁也会有竞争。如，A 线程和 B 线程并发，A 操作的某个变量 x 和 B 操作的某个变量 y 在同一个高速缓存线中，那么 A、B 线程事实上就存在竞争。或者更有，A、B操作同一个变量 z，那么在同一时刻 CPU 只会让一个线程使用 L2缓存线，另一个就只能将数据放在了低速线上，这样就使得速度比单线程要低，产生竞争。</li><li>不是因为锁的存在才有竞争，锁正是为了减少竞争而引进的，因为如果不加锁那么多个线程可以在同时操作某个资源，这会带来更大的损耗。</li></ul><h4 id="什么是“临界区”"><a href="#什么是“临界区”" class="headerlink" title="什么是“临界区”"></a>什么是“临界区”</h4><p>临界区(Critical Section): 是指某个共享资源可以被多个线程访问，我们要保证在一个时间段内只有一个线程可以访问，即一个线程的不可分割的、原子性的一串操作，否则会造成非预期的运行结果。如一个变量，网络连接，外围设备等。我们要保护这个临界区在一段时间内只能被一个线程使用。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1frllqkv5urj30cq0i876a.jpg" alt=""></p><p>一般的，假设对于一个线程来说它总要做以下的事情：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frm912ldfrj30te0d275y.jpg" alt=""></p><h3 id="2-单机中线程”同步”方法的发展"><a href="#2-单机中线程”同步”方法的发展" class="headerlink" title="2. 单机中线程”同步”方法的发展"></a>2. 单机中线程”同步”方法的发展</h3><h4 id="便条-Note"><a href="#便条-Note" class="headerlink" title="便条(Note)"></a>便条(Note)</h4><p>留下便条高速别人将要使用临界区。有两种方式：</p><ul><li>先检测Note，再留 Note，操作，移除 Note</li></ul><p>检测Note与留 Note 之间的空隙，可能会使 A、B 线程都留下 Note，然后都操作了资源。都进入了临界区。这是非法的。</p><ul><li><p>先留 Note，再检测Note，移除 Note/操作后移除 Note</p><p>严格交叉操作后，A、B 都直接移除了Note，最终都没有对资源操作。都没有进入临界区。这是非法的。</p></li></ul><blockquote><p>本质上是检测、留 Note、临界区操作的间隙引起，需要引入原子性操作。</p></blockquote><p>当引入了原子性操作后，不再会重复操作或都不操作。但是当 A 在临界区操作时，B 只能原地等待，即不断的检测 Note 是否已经移除。造成了CPU资源的浪费。</p><h3 id="锁-Lock"><a href="#锁-Lock" class="headerlink" title="锁(Lock)"></a>锁(Lock)</h3><p>便条同步方法的缺陷在于一个线程指令之间的空隙会被另一个线程所“钻入”跑指令，我们一直在把每条指令作为调整对象，并试图为了不让 A 线程钻入 B 线程的指令间隙而让 A 线程循环等待，看似可行但浪费了 CPU 的资源耗在了循环等待上，且不具有对称性（只不能让任意的线程来进行这种循环等待而解决问题）。</p><p>当在细节中很难处理时，我们或许可以调整一下思考的维度，既然指令间隙是关键，我们提高抽象的层次，把一组原子性操作的指令作为调整对象，这是一个“块”的概念，怎么让只有一个线程获得这个块是现在要做的？</p><ul><li><p>比如，之前的指令都是在房间内喂鱼，现在我们考虑怎么用锁锁住房间，只有锁打开另一个线程才能拿起锁、进入、锁上。一个线程要做的就是：</p><ul><li><code>等待锁开</code> -&gt; <code>拿到锁并锁上</code>（一个原子性操作，否则要是存在间隙，拿到锁后没有锁上，CPU 切到另一个线程看到没锁上，前去以为自己也拿到锁，然后临界区就会有2个线程，非法的）-&gt; <code>完成临界区步骤</code>  -&gt; <code>开锁</code></li></ul><p>如下图，lock() 就代表房间被锁上，这样另一个人（线程）就进不去。lock() 与 unlock() 之间的部分已经可以看成是 Critical Section。但这样带来一个问题，一旦这个 Critical Section 如果很费时间，那另一个线程就只能干等（CPU 还会在其间切换的为它工作）这么长时间。</p></li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1frm94um26yj30im08idgu.jpg" alt=""></p><ul><li><p>现在考虑，可否将锁定的临界区的时间消耗减少，我们把喂鱼这个操作从临界区中踢出来，用一个指示性的标志（这个标志一定在喂鱼前会检查一下，或留下这个标志），那么如果我们锁住了这个“标志”，其他线程即使后来进了房间看到标志后也会再出去。</p><p>我们依然引入 Note 这个标志，在喂鱼操作前一定要执行检查 Note 或者留下 Note 这个操作，那么线程即使有两个线程前后进了房间，一个在喂鱼，一个在检查 Note 标志，根据留言判断：是否是出去还是去喂鱼。因而，我们现在用锁锁住“检查 Note” 和“留下 Note” 这个指令组，目的是把它们变成原子性操作，这个 Note 就将其他线程都挡下来。</p><p>现在 Critical Section 就是 <strong>检查 Note</strong> 这个条件语句。这样其他线程在<code>等待锁开</code>这里不再需要太多的等待，因为和后面实际操作没有联系。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frmivqugtuj30l80dcdhs.jpg" alt=""></p><blockquote><p>！！！ 这里是否有问题，当第一次检查是由 Note, 然后就不会留下 Note，当继续下一次检查时 Note 已经被移除，那么进入条件句，最后却要移除 Note？？？</p></blockquote></li></ul><h4 id="睡眠与唤醒-Sleep-and-Wakeup"><a href="#睡眠与唤醒-Sleep-and-Wakeup" class="headerlink" title="睡眠与唤醒(Sleep and Wakeup)"></a>睡眠与唤醒(Sleep and Wakeup)</h4><p>Sleep and Wakeup 机制是为了解决 Critical Section Lock 期间CPU 资源浪费的问题,即使如上的最后的改进方案还是需要等待 Critical Section 直到 Unlock.</p><p>Sleep and Wakeup采用的是，当线程得知资源暂时不可用（lock）就 Sleep，即挂起状态，CPU 不会分配资源给它；一旦资源得到释放（unlock），释放资源的那个线程就会发送 Wakeup 信号给正在 Sleeping 的排队在最前的那位，那这个线程就会被Wakeup，得到资源使用权。</p><p>生产者与消费者(Producer and Consumer):</p><ul><li><p>当队列空的，当CPU 切换到Consumer， 当一个 Consumer 想去消费，然后进入 Sleep</p></li><li><p>当队列满的，当CPU 切换到 Producer，当一个 Producer 想继续生产，然后进入 Sleep</p></li><li><p>当队列是满的，此时 Producer 是 Sleep，当CPU 切换到Consumer，在消费一个后，发信号给 Producer 需要生产了</p></li><li><p>当队列是空的，此时 Consumer 是 Sleep，当CPU 在切换到 Producer，在生产一个后，发信号给Consumer可以来消费了</p></li><li><p>生产者消费者模式也称为“有限缓存模型”，缓存的存在主要是为了减少每一次生产、消费都要进行锁的操作。当缓存不是满或空的状态，生产者和消费者都能自己正常工作，不会进入 Sleep，自然也就不需要Wakeup。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-25-022946.png" alt=""></p></li></ul><p>Sleep and Wakeup 的信号丢失问题，将产生死锁，生产者与消费者都不会继续推进：</p><p>原因是，Consumer接收Sleep信号后与 Sleep动作 有间隙。</p><p>解决办法：引入旗语，把对方发的信号都累积起来，避免丢失。</p><h4 id="旗语-semaphore"><a href="#旗语-semaphore" class="headerlink" title="旗语(semaphore)"></a>旗语(semaphore)</h4><p>本质上是一个计数器，有Up 与 Down 操作，且 Up、Down 都是原子性操作。旗语对线程的操作和 Sleep and Wakeup 类似，当值=0时，消费线程就会Sleep；当值=上界，生产线程就会 Sleep。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1frmloy1w2cj30zy0cagq4.jpg" alt=""></p><p>一般的旗语可以类比公共图书馆，而且不会有滞纳金。比如图书馆里有5本 Python cookbook，当先到的前5个人都借去了，再来的人只能先回去；等其中一个（不管哪个）还来一本，图书馆就会通知之前排队在前的来取，若是没有人在排队，图书馆就会上架图书。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-24-133444.png" alt=""></p><p>常见的是二元信号量，只有0 、1两个取值。那么 Down 至0 和 Up 至 1 就类似于锁的获得和释放。注意的是，二元信号量是有Sleep 和 Wakeup的，不同于锁的等待。以下的 Busy / Free 就相当于锁的获得，锁的释放。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-24-130804.png" alt=""></p><h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h4><p>Monitor = Lock + Condition Variables</p><p>Lock：锁住 Critical Section</p><p>Condition Variables：在 Critical Section 中控制线程 Sleep 或 Wakeup。线程 sleep 与释放锁操作是原子性的，没有间隙；否则会出现有两个线程同时活跃在 Critical Section 的情况。 尽可能的让在Monitor 中让线程做的工作少，在 Monitor 外的部分处理 Monitor 内部分的结果，让不同的线程在 Monitor 中可以更快的响应。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-24-142641.png" alt=""></p><h3 id="3-多计算机之间的线程同步"><a href="#3-多计算机之间的线程同步" class="headerlink" title="3. 多计算机之间的线程同步"></a>3. 多计算机之间的线程同步</h3><p>Monitor的缺点：</p><ol><li>依赖于编译器将同步源语加在 Monitor 的开始和结尾</li><li>只能在单机上使用</li></ol><p>消息传递：Send/Receive，以下是用消息传递实现 Producer and Consumer，并定义了缓存大小100</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-25-030714.png" alt=""></p><p>消息传递可以在多态计算机之间进行线程同步，是目前流行的方法。其特有的方式使得不存在像 Sleep and Wakeup的死锁，也不会有繁忙的等待消耗 CPU。</p><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Critical_section</a></p><p><a href="https://cs162.eecs.berkeley.edu/static/lectures/7.pdf" target="_blank" rel="noopener">https://cs162.eecs.berkeley.edu/static/lectures/7.pdf</a></p><p><a href="https://cs162.eecs.berkeley.edu/static/lectures/8.pdf" target="_blank" rel="noopener">https://cs162.eecs.berkeley.edu/static/lectures/8.pdf</a></p><p><a href="https://www.justsoftwaresolutions.co.uk/threading/locks-mutexes-semaphores.html" target="_blank" rel="noopener">https://www.justsoftwaresolutions.co.uk/threading/locks-mutexes-semaphores.html</a></p><p><a href="https://9p.io/sys/doc/sleep.html" target="_blank" rel="noopener">https://9p.io/sys/doc/sleep.html</a></p><p><a href="https://www.cs.cornell.edu/courses/cs4410/2008fa/lectures.html" target="_blank" rel="noopener">https://www.cs.cornell.edu/courses/cs4410/2008fa/lectures.html</a></p><p><a href="http://www.personal.kent.edu/~rmuhamma/OpSystems/os.html" target="_blank" rel="noopener">http://www.personal.kent.edu/~rmuhamma/OpSystems/os.html</a></p><p><a href="http://www.cse.iitm.ac.in/~chester/courses/15o_os/syllabus.html" target="_blank" rel="noopener">http://www.cse.iitm.ac.in/~chester/courses/15o_os/syllabus.html</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo搭建博客</title>
      <link href="/2018/05/23/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/05/23/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><div class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div><br></div></p><blockquote><p>Update @ 2018-05-23 10:53:21:</p></blockquote><ul><li>使用 Next Mist</li><li>改变了文章页面的背景色</li><li>改变了 header 的高度，设置了背景，调整了 site title 和 menu 的布局，增加了动画效果</li><li>在 Home 页面，设置“巧克力块”背景色效果，文章之间用原白色背景色隔开</li></ul><a id="more"></a><hr><hr><p><div class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div><br></div></p><blockquote><p>Update @ 2018-05-10 21:25:36:</p></blockquote><ul><li>增加了将文章中图片进行宽度高度设定的功能，加上了边框。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*add to make images in article center*/</span></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: block;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">550px</span>;</span><br><span class="line">   <span class="attribute">height</span>: auto;</span><br><span class="line">   <span class="attribute">margin</span>: auto;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#88acdb</span>;</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">2%</span>;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!--more--><ul><li>尝试添加阅读百分比功能</li></ul><p>在 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a> 中移植源码，已经移植了 <code>scrollpercent</code> 相关的css/swig代码，但只能显示图标并不能实现跳转到顶部和显示百分比。 通过跑 next 主题发现，应该还需要 <code>scrollspy</code> 这个代码。</p><hr><hr><p><div class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div><br></div></p><blockquote><p>Update @ 2018-05-04 16:31:01:</p></blockquote><p>Hexo框架有着更全的文档，是更加流行的静态网站搭建框架。在这里记录一下用 Hexo 搭建博客的过程和对遇到问题的解决方法。</p><hr><h2 id="i-Hexo-的安装"><a href="#i-Hexo-的安装" class="headerlink" title="i. Hexo 的安装"></a>i. Hexo 的安装</h2><p>在已经安装 <code>npm</code> 的基础上安装。</p><h3 id="1-安装npm-cnpm"><a href="#1-安装npm-cnpm" class="headerlink" title="1.  安装npm(cnpm)"></a>1.  安装npm(cnpm)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装hexo</span></span><br><span class="line">$ npm install hexo-cli g</span><br><span class="line"><span class="comment">## 因为网络缘故，在国内使用 node.js 的原生工具 npm 直接安装可能无法正常进行，可以采用淘宝前端组的国内镜像安装cnpm，而后以下步骤可以使用其定制的 cnmp 工具代替 npm。</span></span><br><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><!--more--><h3 id="2-初始化博客文件夹-创建博客文件夹"><a href="#2-初始化博客文件夹-创建博客文件夹" class="headerlink" title="2. 初始化博客文件夹,创建博客文件夹"></a>2. 初始化博客文件夹,创建博客文件夹</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog`</span><br></pre></td></tr></table></figure><p>这时会显示如下，给出需要手动安装依赖的警示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INFO  Cloning hexo-starter to ~/Project/for_Blog_Test/hexoBlog/myblog</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">ERROR: install is not COMMAND nor fully qualified CLASSNAME.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">WARN  Failed to install dependencies. Please run <span class="string">'npm install'</span> manually!</span><br></pre></td></tr></table></figure><h3 id="3-切换到博客文件夹路径，安装Hexo的扩展插件"><a href="#3-切换到博客文件夹路径，安装Hexo的扩展插件" class="headerlink" title="3. 切换到博客文件夹路径，安装Hexo的扩展插件"></a>3. 切换到博客文件夹路径，安装Hexo的扩展插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>然后可以看到层级目录, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml  <span class="comment">#站点的配置信息</span></span><br><span class="line">├── node_modules  <span class="comment">#node 模块组件</span></span><br><span class="line">├── package-lock.json </span><br><span class="line">├── package.json  <span class="comment">#应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除</span></span><br><span class="line">├── scaffolds  <span class="comment">#模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span></span><br><span class="line">├── <span class="built_in">source</span>  <span class="comment">#资源文件夹是存放用户资源的地方。</span></span><br><span class="line">└── themes  <span class="comment">#主题文件夹，Hexo 将根据这个主题来生成静态页面</span></span><br></pre></td></tr></table></figure><h3 id="4-安装其它插件"><a href="#4-安装其它插件" class="headerlink" title="4. 安装其它插件"></a>4. 安装其它插件</h3><ul><li>本地服务<br><code>$ npm install hexo-server --save</code></li><li>站点后台服务<br><code>$ npm install hexo-admin --save</code></li><li>存档<br><code>$ npm install hexo-generator-archive --save</code></li><li>RSS<br><code>$ npm install hexo-generator-feed --save</code></li><li>全局搜索<br><code>$ npm install hexo-generator-search --save</code></li><li>标签云<br><code>$ npm install hexo-generator-tag --save</code></li><li>git部署<br><code>$ npm install hexo-deployer-git --save</code></li><li>站点<br><code>$ npm install hexo-generator-sitemap --save</code></li></ul><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><p>生成一个demo.md 文件，在../source/_post/<br><code>$ hexo new post demo</code><br>本地生成静态页面，启动本地服务（开启调试功能将会输出更多的信息），在 <a href="http://localhost:4000/" target="_blank" rel="noopener">localhost:4000</a>查看<br><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s --debug</code></p><h3 id="6-Hexo-命令"><a href="#6-Hexo-命令" class="headerlink" title="6.Hexo 命令"></a>6.Hexo 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g：hexo generate</span><br><span class="line">hexo c：hexo clean</span><br><span class="line">hexo s：hexo server</span><br><span class="line">hexo d：hexo deploy</span><br></pre></td></tr></table></figure><hr><h2 id="ii-Hexo框架使用"><a href="#ii-Hexo框架使用" class="headerlink" title="ii. Hexo框架使用"></a>ii. Hexo框架使用</h2><h3 id="1-配置文件要注意的地方"><a href="#1-配置文件要注意的地方" class="headerlink" title="1. 配置文件要注意的地方"></a>1. 配置文件要注意的地方</h3><p>Hexo 框架有两个配置文件，分别是站点配置文件 ../blog/_config.yml 和 主题的配置文件../blog/themes/yelee/_config.yml,在此将前者称为站点配置，后者称为主题配置。 </p><h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h4><ul><li>Site</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment">#博客标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="comment">#博客子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment">#简单介绍</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="comment">#博客作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="comment">#博客主要语言类型</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"><span class="attr">since:</span> <span class="comment">#站点开始年份</span></span><br></pre></td></tr></table></figure><ul><li>URL</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="comment">#你要部署的网址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><ul><li>Writing</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>   <span class="comment">#默认的博客页面类型</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span>  <span class="comment">#高亮部分使用 prettify 实现，将这里自带的高亮关闭了</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br></pre></td></tr></table></figure><ul><li>部署  </li></ul><p>只有这里配置了，才能通过 <code>hexo d</code>来一键部署</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="comment"># git ssh</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><ul><li>高亮相关</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_style:</span></span><br><span class="line"><span class="attr">  on:</span> <span class="literal">false</span> <span class="comment">#这里使用了 prettify 所以关闭了自带的，要启用自带的需要设置为 true</span></span><br><span class="line"><span class="attr">  inline_code:</span> <span class="number">4</span>  <span class="comment"># Value: 0 - 9 可选</span></span><br><span class="line"><span class="attr">  code_block:</span> <span class="number">4</span> <span class="comment"># Value: 0 - 4 </span></span><br><span class="line">  <span class="comment"># Set inline_code to style highlight text</span></span><br><span class="line">  <span class="comment"># Chose a highlight theme for code block</span></span><br><span class="line">  <span class="comment"># 通过 inline_code 切换内置文本高亮样式</span></span><br><span class="line">  <span class="comment"># 通过 code_block 切换内置代码高亮配色主题</span></span><br></pre></td></tr></table></figure><ul><li>友情链接</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">  Hexo:</span> <span class="attr">https://hexo.io</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="comment">#github地址</span></span><br></pre></td></tr></table></figure><ul><li>选项页面打开方式</li></ul><p><strong>true</strong> 表示在新的标签页中打开，<strong>false</strong>在本标签页打开</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">open_in_new:</span></span><br><span class="line"><span class="attr">  global:</span> <span class="number">2</span> <span class="comment"># 0-2</span></span><br><span class="line"><span class="attr">  title:</span> <span class="literal">false</span> <span class="comment"># article title in homepage 主页文章标题</span></span><br><span class="line"><span class="attr">  post:</span> <span class="literal">false</span> <span class="comment"># link within post/page 正文中的链接</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="literal">false</span> <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="literal">false</span> <span class="comment"># 分类</span></span><br><span class="line"><span class="attr">  article_nav:</span> <span class="literal">false</span> <span class="comment"># 导航</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="literal">true</span> <span class="comment"># 归档</span></span><br><span class="line"><span class="attr">  mini_archives:</span> <span class="literal">true</span> <span class="comment"># 迷你归档</span></span><br><span class="line"><span class="attr">  menu:</span> <span class="literal">false</span> <span class="comment"># 边栏菜单</span></span><br><span class="line"><span class="attr">  friends:</span> <span class="literal">true</span>  <span class="comment"># 友情链接</span></span><br><span class="line"><span class="attr">  socail:</span> <span class="literal">true</span> <span class="comment"># 社交图标</span></span><br></pre></td></tr></table></figure><ul><li>网页标签的显示</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tab Title Change | 标签页标题切换</span></span><br><span class="line"><span class="attr">tab_title_change:</span> </span><br><span class="line"><span class="attr">  on:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  left_tab_title:</span> <span class="string">‘xxxxxx’</span> <span class="comment">#切换到其他页面时的显示</span></span><br><span class="line"><span class="attr">  return_tab_title:</span> <span class="string">''</span> <span class="comment">#在本页面的显示，''显示在看内容的标题</span></span><br></pre></td></tr></table></figure><ul><li>Menu</li></ul><p>默认的 <code>/</code>是指 source 文件夹</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives/</span></span><br><span class="line">  <span class="comment">#随笔: /tags/随笔</span></span><br><span class="line"><span class="attr">  Tags:</span> <span class="string">/tags/</span></span><br><span class="line"><span class="attr">  About:</span> <span class="string">/about/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Link to your avatar | 填写头像地址</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/img/avatar.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Small icon of Your site | 站点小图标地址</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.png</span></span><br></pre></td></tr></table></figure><h3 id="2-建立博客页面必要的操作"><a href="#2-建立博客页面必要的操作" class="headerlink" title="2. 建立博客页面必要的操作"></a>2. 建立博客页面必要的操作</h3><h4 id="配置标签云和类别以及-about-页面"><a href="#配置标签云和类别以及-about-页面" class="headerlink" title="配置标签云和类别以及 about 页面"></a>配置标签云和类别以及 about 页面</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">"tags"</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">"categories"</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">"about"</span></span><br></pre></td></tr></table></figure><p>以上操作会在source 目录下生成 tags、categories、about三个文件夹，里面都对应有一个index.md的文件，在tags文件夹中的index.md中，修改type为tags,如下所示，相应的categories和about也把对应位置的type值改为categories和about。如下，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-05</span><span class="bullet">-04</span> <span class="number">16</span><span class="string">:34:11</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-05</span><span class="bullet">-04</span> <span class="number">16</span><span class="string">:34:11</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h4 id="修改个人头像和网页卡图标"><a href="#修改个人头像和网页卡图标" class="headerlink" title="修改个人头像和网页卡图标"></a>修改个人头像和网页卡图标</h4><ul><li>个人头像</li></ul><p>在<code>..themes/yelle/source/img/</code>中修改</p><ul><li>网页卡图标</li></ul><p>在<code>..themes/yelee/source/</code>生成一个<code>favicon.png</code>，可以使用<a href="http://www.bitbug.net/" target="_blank" rel="noopener">http://www.bitbug.net/</a>来制作。</p><hr><h2 id="iii-常见问题"><a href="#iii-常见问题" class="headerlink" title="iii. 常见问题"></a>iii. 常见问题</h2><ul><li>修改配置文件有误  </li></ul><blockquote><p>冒号后面需要空格</p></blockquote><ul><li>端口占用</li></ul><blockquote><p>关闭正在运行的4000端口；或者使用新的端口<code>hexo s -p 5000</code></p></blockquote><ul><li>配置文件修改后，高亮工作不正常</li></ul><blockquote><p>有的主题在配置文件中没有设定高亮的开关模式有效，需要到主题文件夹目录主题配置文件查看，或许要到 <code>layout, source</code>下查看</p></blockquote><ul><li>使用 Prettify 替代自带的高亮</li></ul><blockquote><p>这篇博文讲的很详细<a href="http://jumpbyte.cn/2016/07/02/use-and-install-prettify/" target="_blank" rel="noopener">http://jumpbyte.cn/2016/07/02/use-and-install-prettify/</a><br>可以高亮代码，可以显示行号</p></blockquote><ul><li>使用 highlight.js 代替自带高亮</li></ul><blockquote><p>可以高亮但是不能显示行号，具体参考<a href="https://blog.csdn.net/melordljm/article/details/51991389" target="_blank" rel="noopener">https://blog.csdn.net/melordljm/article/details/51991389</a></p></blockquote><hr><h2 id="iiii-参考"><a href="#iiii-参考" class="headerlink" title="iiii. 参考"></a>iiii. 参考</h2><blockquote><p><a href="http://jumpbyte.cn/2016/07/02/use-and-install-prettify/" target="_blank" rel="noopener">为hexo博客加入prettify高亮插件</a><br><a href="https://blog.csdn.net/tonydandelion2014/article/details/61615898" target="_blank" rel="noopener">Hexo安装配置详解</a><br><a href="https://blog.csdn.net/melordljm/article/details/51991389" target="_blank" rel="noopener">Hexo高级教程之代码高亮-使用 highlight.js</a><br><a href="http://moxfive.coding.me/yelee/" target="_blank" rel="noopener">Yelle主题 github 文档</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统-7章</title>
      <link href="/2018/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_7%E7%AB%A0/"/>
      <url>/2018/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_7%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h2 id="1-线程的原理"><a href="#1-线程的原理" class="headerlink" title="1. 线程的原理"></a>1. 线程的原理</h2><h3 id="1-1-线程的起源"><a href="#1-1-线程的起源" class="headerlink" title="1.1 线程的起源"></a>1.1 线程的起源</h3><p>现在意义上的线程是轻量级的进程，是进程中指令执行路径的描述，是多个寄存器等变量条件就绪等待 CPU 选择执行的状态，它包含着私有的程序计数器等状态来确定指令的执行顺序。线程是 CPU 利用的最小单元。</p><p>通常，线程和并发联系紧密，在单处理器环境下，多个线程只能并发。具体的，将一个进程切分为多个代码段，每个代码段看做一个线程，这多个线程轮流的使用 CPU，并发的执行。</p><a id="more"></a><ul><li>线程发明的历史表明，在早期并没有线程的命名，那时将一连串的控制流程称为 <code>process</code>。这时的 process 是可以共享内存空间，通过共享变量，旗语来交流。</li><li>到后来的 Unix 中process 的概念变为由一连串的控制指令执行过程加上虚拟地址空间。这变得很笨重。它们有各自的地址空间，不共享一个内存空间，只能通过管道、信号来交流，共享内存（更为庞杂的机制）是后续才加上的。</li><li>Unix用户开始想念早前的 process 的方便，它们可以方便的共享内存空间，于是<code>Thread</code>的名称出现了，是早期 processes 共享一个Unix意义下的 process的内存空间，相对于 Unix 下process 的笨重，thread 是轻量级的。<code>Thread</code>命名在操作系统领域中诞生了。</li></ul><p>因此发明<code>thread</code>的动机是：让轻量级的 processes 可以共享资源，方便操作。线程之间的切换的代价比进程之间切换要小得多。</p><h3 id="1-2-线程是并行的吗？"><a href="#1-2-线程是并行的吗？" class="headerlink" title="1.2 线程是并行的吗？"></a>1.2 线程是并行的吗？</h3><p>对于单核系统，事实上，同一个时刻CPU 只能运行一个线程。当一个进程包含多个线程，人们也许会感觉到线程是同时工作的，这是 CPU 快速切换不同线程工作的结果。比如：在 Word 中输入文字，自动调整格式和显示文字是两个线程，在单核中，CPU 会迅速切换工作，让用户感觉文字在输入后就自动的按照格式显示了，像是在同时进行。这是人的感官层次上的并行。</p><p>对于多核系统，两个线程同时在不同核运行时可以的，这是真正意义上的操作系统层次的并行。这使得多核计算机可以最大化利用率。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-081231.png" alt=""><br><em>image caption</em></p><h3 id="1-3-线程是并发的"><a href="#1-3-线程是并发的" class="headerlink" title="1.3 线程是并发的"></a>1.3 线程是并发的</h3><ul><li><p><strong>并发: </strong> 当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(<code>Concurrent</code>)。</p><ul><li>并发，在<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>中，是指一个时间段中有几个线程都处于已启动运行到运行完毕之间，且这几个线程都是在同一个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>上运行，但任一个时刻点上只有一个程序在处理机上运行。</li></ul></li><li><p><strong>并行：</strong>当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(<code>Parallel</code>)。</p></li><li><strong>区别：</strong>并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">多道程序</a>环境下，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E6%80%A7" target="_blank" rel="noopener">并发性</a>是指在一段时间内宏观上有多个程序在同时运行，但在<a href="https://baike.baidu.com/item/%E5%8D%95%E5%A4%84%E7%90%86%E6%9C%BA%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">单处理机系统</a>中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">计算机系统</a>中有多个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>，则这些可以并发执行的程序便可被分配到多个处理机上，实现<a href="https://baike.baidu.com/item/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">并行执行</a>，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。 </li></ul><h3 id="1-4-管理线程"><a href="#1-4-管理线程" class="headerlink" title="1.4 管理线程"></a>1.4 管理线程</h3><p>操作系统需要知道线程的一切信息，便于对线程进行有效的管理。每个线程就是一个特定的<code>指令执行序列</code>，需要有自己私有的资源，这些对每个线程都是私有的信息放在<code>线程控制表</code>。同时，线程共享同一个进程的地址空间，这个由进程管理即可。就像宿舍中，有些设备、物品是共享的，有些东西是私有的。</p><p>原则是，让共享的资源在保证线程正常工作的情况下越多越好。私有资源可以保证一个线程能够完成它的<code>指令执行序列</code>。程序计数器 PC 肯定要私有，不然线程都不知道下一个它该执行的指令，寄存器、栈、状态字这些都包含着指令执行的变量信息，CPU 状态，如果被其他线程共享改动会使本线程不能正常运行。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-082737.png" alt=""></p><p>下图显示了当有进程中有多线程时线程私有资源和公有资源，以及说明：</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-120638.png" alt=""></p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-120845.png" alt=""></p><h3 id="1-4-线程的实现方式"><a href="#1-4-线程的实现方式" class="headerlink" title="1.4 线程的实现方式"></a>1.4 线程的实现方式</h3><p>线程的实现是通过不同的管理方式来实现。</p><h4 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h4><p>由进程自己管理线程，内核中都不知道多个线程的存在，只能意识到只有一个正在运行的线程。对于进程，每个进程都会有一个<code>线程库</code>，其中包含的代码可以做到创建线程、销毁线程，线程之间的交流，线程执行的调度，线程状态的恢复等。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-083926.png" alt=""></p><p>优点：</p><ul><li>线程之间的切换不需要内核权限</li><li>因为和内核无关，可以在任何操作系统中运行</li><li>更快的创建和管理线程</li></ul><p>缺点：</p><ul><li>因为不能和内核有关系，所有大部分的系统调用被禁止。</li><li><p>编程变得很复杂，一方面要推动进程的执行，一方面又要处理好线程的调度。</p></li><li><p>因为多个线程对于内核而言它只能意识到在同不同时刻只有一个线程在运行，意识不到多个线程的存在，因此即使在多处理系统(Multiprocessing)中，内核也不会同时分配多个 CPU 来运行同一个进程中的多个线程。</p></li></ul><h4 id="内核态线程"><a href="#内核态线程" class="headerlink" title="内核态线程"></a>内核态线程</h4><p>由操作系统内核管理线程，线程控制块放在内核中，拥有线程的所有资料，这样操作系统就同时掌握进程控制块和线程控制块，因此可以对线程进行调度、资源分配，安全措施，这些都是内核自动完成，不需要用户在程序中设定这种调度、分配，当在多处理(Multiprocess)环境中，内核意识到一个进程中有多个线程，可以同时用多个 CPU 来运行多个线程。因而，任何程序都可以被编写为多线程，在用户编写的程序进程中不存在管理线程的代码，因为内核会自动的采取调度方法来最大效率的并行执行线程。</p><p>优点：</p><ul><li>在多进程中，内核可以根据掌握的所有不同进程中的线程进行统一调度。</li><li>因为内核监视着线程的执行，当一个线程阻塞，内核可以调度此进程中的另一个线程继续工作。</li></ul><p>缺点：</p><ul><li>效率低，每次线程切换都要从用户态陷入到内核态，由内核来调度。</li><li>占用内核空间</li><li>和操作系统直接相关，不能在不同的内核上运行。</li></ul><h3 id="1-5-多线程模型"><a href="#1-5-多线程模型" class="headerlink" title="1.5 多线程模型"></a>1.5 多线程模型</h3><p>现代操作系统是用户态线程和内核态线程的组合模型。这使得对同一个应用程序，在多处理器操作系统中，它的多个线程也能并行（时有对一个进程有多个内核态线程可以服务时，才会有并行）。如下，在多处理器环境下，多对多和一对一都可以做到一个进程中线程的并行，因为内核可以选择同时运行同一个进程的用户态线程对应的内核态线程。注意，只有内核态线程可以并行。</p><ul><li><p>多对多模型（M:N, M&gt;=N, M 用户态线程个数，N 内核态线程个数）</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-123216.png" alt=""></p></li><li><p>多对一模型（M:1）</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-123401.png" alt=""></p></li><li><p>一对一（进程中的一个用户态线程对应一个内核态线程）（1:1）</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-123554.png" alt=""></p></li></ul><p>内核态的多个线程才能具备并行的能力，用户态多个线程不具备这个能力。用户态的多个线程要想也能够并行的执行，必须告知内核它有多个线程需要执行，而办法是通过内核态线程来和用户态线程取得某种联系。内核态进程可以看做是用户态进程与内核沟通的桥梁。</p><h3 id="1-6-常见疑惑"><a href="#1-6-常见疑惑" class="headerlink" title="1.6 常见疑惑"></a>1.6 常见疑惑</h3><ul><li><p>在多处理器上系统中，不同进程的线程能否并行？</p><p>不能！首先即使在多处理器环境下，进程调度的目的就是最大化的考虑进程响应时间、CPU 利用率、CPU 占用公平性，同一时刻只会有一个进程在使用 CPU。</p></li><li><p>在多处理器上系统中，同一个进程的线程能否并行？</p><p>可以！前提是线程模型采用的是多对多或1对1，借助于内核态线程达到同一个进程中多线程的并行。</p></li></ul><h3 id="1-7-参考"><a href="#1-7-参考" class="headerlink" title="1.7 参考"></a>1.7 参考</h3><blockquote><p><a href="https://stackoverflow.com/a/5201879/6170444" target="_blank" rel="noopener">https://stackoverflow.com/a/5201879/6170444</a></p><p><a href="https://www.geeksforgeeks.org/operarting-system-thread/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/operarting-system-thread/</a></p><p><a href="http://www.serpentine.com/blog/threads-faq/the-history-of-threads/" target="_blank" rel="noopener">http://www.serpentine.com/blog/threads-faq/the-history-of-threads/</a></p><p><a href="https://www.tutorialspoint.com/operating_system/os_multi_threading.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/operating_system/os_multi_threading.htm</a></p><p><a href="https://cs162.eecs.berkeley.edu/" target="_blank" rel="noopener">https://cs162.eecs.berkeley.edu/</a></p><p><a href="https://www.youtube.com/watch?v=5Ip__MiHRxw&amp;index=3&amp;list=PLggtecHMfYHA7j2rF7nZFgnepu_uPuYws" target="_blank" rel="noopener">https://www.youtube.com/watch?v=5Ip__MiHRxw&amp;index=3&amp;list=PLggtecHMfYHA7j2rF7nZFgnepu_uPuYws</a></p><p><a href="https://blog.csdn.net/claram/article/details/52094587" target="_blank" rel="noopener">https://blog.csdn.net/claram/article/details/52094587</a></p><p><a href="https://stackoverflow.com/questions/41647778/does-user-level-threads-take-advantage-of-multiprocessing" target="_blank" rel="noopener">https://stackoverflow.com/questions/41647778/does-user-level-threads-take-advantage-of-multiprocessing</a></p><p><a href="https://www.geeksforgeeks.org/operating-system-difference-multitasking-multithreading-multiprocessing/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/operating-system-difference-multitasking-multithreading-multiprocessing/</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统-5|6章</title>
      <link href="/2018/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5_6%E7%AB%A0/"/>
      <url>/2018/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5_6%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h2 id="1-进程调度"><a href="#1-进程调度" class="headerlink" title="1. 进程调度"></a>1. 进程调度</h2><h3 id="1-1-什么是进程调度"><a href="#1-1-什么是进程调度" class="headerlink" title="1.1 什么是进程调度"></a>1.1 什么是进程调度</h3><p>进程调度是系统有安排的让 CPU 运行不同的进程任务。同时考虑到最大化 CPU 的利用率，又要考虑到进程的平均响应时间，和进程占用 CPU 时间的公平。进程调度的目标是尽可能的实现 CPU 的效率的最大化，又要最小化进程的响应时间。<br><a id="more"></a></p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-19-091954.png" alt=""></p><h3 id="1-2-进程调度的算法"><a href="#1-2-进程调度的算法" class="headerlink" title="1.2 进程调度的算法"></a>1.2 进程调度的算法</h3><p>进程调度问题是个很久远的问题，产生了多种进程调度的算法，目前用的较多的是混合优先级调度算法。</p><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><p>FCFS，First Come First Service. 就像排队，先请求的进程优先服务。显然这种算法的平均响应时间较高。</p><h4 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h4><p>每个进程服务固定的时间，如A 进程20ms，然后 B 进程20ms，。。。 Z 进程20ms，再次 A 进程20ms。如此轮转的选择进程运行固定的时间片。 注意进程的切换也需要时间，这种算法的平均响应时间可能还会大于 FCFS 算法。</p><h4 id="短任务优先算法"><a href="#短任务优先算法" class="headerlink" title="短任务优先算法"></a>短任务优先算法</h4><p>系统会对进程的运行时间有个评估，让时间最短的最先运行。才用贪心策略的这种算法能获得最好的平均响应时间。但是这会使得需要长时间运行的进程饥饿，并且我们并不能知道我们要运行的进程确定的运行时间。一个解决办法是启发式方法，即我们不能精确的给出一个进程的运行时间，我们可以通过它的大小来推断运行时间。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>考虑到有的进程任务是重要的有的是不重要的，如内核程序和用户程序。设置优先级能将优先级最高的进程最先完成，要让每个进程都能合理的占用 CPU，可以动态的调整优先级来达到。</p><h4 id="混合调度算法"><a href="#混合调度算法" class="headerlink" title="混合调度算法"></a>混合调度算法</h4><p>混合 优先级调度算法和时间片轮转算法，将进程分为几个大类，每个大类设置优先级，在每个大类中采用时间片轮转算法。</p><h4 id="实时调度算法-realtime"><a href="#实时调度算法-realtime" class="headerlink" title="实时调度算法 (realtime)"></a>实时调度算法 (realtime)</h4><p>对于某些进程任务具有很高的重要性，我们必须在规定的时间内完成，都这将会造成严重的后果。实时调度算法考虑的是每个进程任务必须在规定的时间内完成，并不去考虑响应时间或是吞吐率。</p><ul><li>最小截至时间优先：EDF, Earliest Deadline First。当新的进程来了，系统立刻检查所有进程中最早结束的进程，且抢占式的运行。是一种动态的分配优先级。动态优先级适用于任务源源不断产生，且不清楚任务的运行状况，并让所有的进程不感到饥饿。</li><li>最短周期优先（单调速率调度）：RMS, Rate Monotonic Scheduling。是一种静态优先级调度。事先已经设置好的优先级，在没有特权的情况下不能更改优先级。</li></ul><h3 id="1-3-进程调度的过程"><a href="#1-3-进程调度的过程" class="headerlink" title="1.3 进程调度的过程"></a>1.3 进程调度的过程</h3><ul><li><p>因时序、外部中断、进程挂起等使得操作系统获得CPU 的控制权</p></li><li><p>操作系统在所有就绪的进程中按照某个算法选择进程</p></li><li><p>若选择的不是当前的进程，则将当前的状态保存，</p></li><li><p>将选中的进程的运行条件设置好，切换运行选中的进程</p><p>下图显示进程P0和进程 P1的调度运行。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-120208.png" alt=""></p></li></ul><h3 id="1-4-优先级倒挂-Priority-Inversion"><a href="#1-4-优先级倒挂-Priority-Inversion" class="headerlink" title="1.4 优先级倒挂 (Priority Inversion)"></a>1.4 优先级倒挂 (Priority Inversion)</h3><p>是指低优先级的进程比高优先级的进程先占用 CPU 运行，这和优先级算法是相悖的。具体的有两种优先级倒挂的形式：</p><ul><li>第一种是，低优先级进程L与高优先级进程 H共享一个资源，低优先级已经将资源锁定，等有高优先级的进程到来时因为它需要这个共享资源，所以不能抢占CPU ，要等到 L 进程将共享资源释放后 H 进程才能占用 CPU。 这就造成了低优先级的进程比高优先级进程先运行。</li><li>第二种是，有3个进程，L 低优先级，M 中等优先级，H 高优先级，L 锁住了 H 要用的资源，同时 M 不需要这个资源可以抢占 L 之前运行，这时L 和 H 都不会运行，要等到 M 运行结束后 L 运行，等 L 释放资源后，H 运行。<br>常用的解决办法是：</li><li>优先级继承(Proirity Inheritance),让锁住资源的低优先级进程暂时继承比需要资源的高优先级进程更高的优先级, 使得资源尽快的释放.</li><li>禁止中断: 主要针对第二种优先级倒挂的情况,使得 M 进程不能抢占CPU。</li></ul><h3 id="1-5-参考"><a href="#1-5-参考" class="headerlink" title="1.5 参考"></a>1.5 参考</h3><blockquote><p><a href="https://wenku.baidu.com/view/eb543ce29b89680203d825d7.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/eb543ce29b89680203d825d7.html</a><br><a href="https://www.embedded.com/design/configurable-systems/4024970/How-to-use-priority-inheritance" target="_blank" rel="noopener">https://www.embedded.com/design/configurable-systems/4024970/How-to-use-priority-inheritance</a><br><a href="https://www.quora.com/What-is-priority-inversion" target="_blank" rel="noopener">https://www.quora.com/What-is-priority-inversion</a><br><a href="https://www.embedded.com/design/configurable-systems/4024970/How-to-use-priority-inheritance" target="_blank" rel="noopener">https://www.embedded.com/design/configurable-systems/4024970/How-to-use-priority-inheritance</a></p></blockquote><hr><hr><h2 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2. 进程通信"></a>2. 进程通信</h2><p>进程之间的通信也是模仿了人类社会中的通信方法，一个发一个收，多个发多个收，大家在一起讲话各自取得个字咬的信息。父进程与子进程之间通信，普通进程之间通信。</p><h3 id="2-1-点到点连接通信"><a href="#2-1-点到点连接通信" class="headerlink" title="2.1 点到点连接通信"></a>2.1 点到点连接通信</h3><h4 id="管道（pipe）"><a href="#管道（pipe）" class="headerlink" title="管道（pipe）"></a>管道（pipe）</h4><p>一个发一个收。一个进程要和另一个进程通信，A 进程创建一个管道，并标明目标通信的进程B。A写入管道，B从管道取出。创建一个管道必须要标明发送端和接收端。</p><p>类似真实的管道，建设好后使用。</p><p>特点：必须事先建立好两端之间的连接。只能是一个读、另一个写，方式确定。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-115145.png" alt=""></p><h4 id="套接字（socket）"><a href="#套接字（socket）" class="headerlink" title="套接字（socket）"></a>套接字（socket）</h4><p>通信双方都要创建一个套接字，一个作为服务方套接字，一个属于服务方套接字。具体工作过程：服务器套接字在监听请求，客户端创建的套接字向服务方发送服务请求，服务方将会创建一个客户端套接字与远程客户端对应点对点的连接。然后双方就可以使用发送和接收功能来交流。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-111115.png" alt=""></p><h3 id="2-2-信号（signal）"><a href="#2-2-信号（signal）" class="headerlink" title="2.2 信号（signal）"></a>2.2 信号（signal）</h3><p>信号本质上是一个内核中的数据结构，发送方将这种数据结构的数据准备好并指明目标就发送。不事先建立连接。通过产生中断给操作系统，操作系统知道有进程要发送信号就按照目标查找接收方发过去。</p><p>类似电报，将报文和收报人交给电报公司，电报公司就发送这个电报（中断）。若收报方不响应，则本次通信结束。</p><h3 id="2-3-信号量（旗语）（semaphore）"><a href="#2-3-信号量（旗语）（semaphore）" class="headerlink" title="2.3 信号量（旗语）（semaphore）"></a>2.3 信号量（旗语）（semaphore）</h3><p>指示当前信道是否正在使用的一个标志量。在一个信道中在一个时刻只能存在一个信号通过，就像火车通过隧道，当有信号正在途中则设置一个标志，否则设置另一个标志，以此来告诉下个信号是否应该到来。</p><h3 id="2-4-共享内存（Share-Memory）"><a href="#2-4-共享内存（Share-Memory）" class="headerlink" title="2.4 共享内存（Share Memory）"></a>2.4 共享内存（Share Memory）</h3><p>通信双方需要共享某些数据，由进程 A 创建一个内存空间，且双方都将内存的物理地址映射到自己的（虚拟）地址空间，这样在操作物理内存中的资源时就像操作自己的空间。较为复杂的方式。两端都可以写读。必须在同一个物理机上。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-19-154358.png" alt=""></p><h3 id="2-5-消息队列"><a href="#2-5-消息队列" class="headerlink" title="2.5 消息队列"></a>2.5 消息队列</h3><p>生产者消费者模式。任何进程都可以写入，任何进程都可以读出。多对多的模式。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-19-155146.png" alt="6"></p><h3 id="2-6-参考"><a href="#2-6-参考" class="headerlink" title="2.6 参考"></a>2.6 参考</h3><blockquote><p><a href="https://cs162.eecs.berkeley.edu/static/lectures/5.pdf" target="_blank" rel="noopener">https://cs162.eecs.berkeley.edu/static/lectures/5.pdf</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序计数器</title>
      <link href="/2018/05/18/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/2018/05/18/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-什么是程序计数器"><a href="#1-什么是程序计数器" class="headerlink" title="1. 什么是程序计数器"></a>1. 什么是程序计数器</h3><p>程序计数器：Program Counter（PC），Instruction Pointer（IP），是一个特殊的寄存器（register），用来存放 CPU 下一个将要执行指令的内存地址(Memory Address),注意它的功能是用来取得程序执行指令内存地址，并不是数据内存地址。   </p><p>一般情况下，当系统重启后，PC 置为0，然后随着系统进程的运行，不断的开始计数。具体的，以一个系统进程为例，PC 开始初始化为0，（我们知道一个指令如果太长的话就会将它切为几段来放置在内存中）。</p><a id="more"></a><ul><li>开始 CPU 获取了 <code>PC=0000H</code> 这个内存地址的指令，同时 <code>PC++</code>，即存储下一条指令的地址。注意，我们唐常说的 PC 加1，其实是让 PC 增加为下一条指令的地址，并不是这个 PC 当前的地址加1，比如一个内存单元占用4个位，0x04，则如果当前 <code>PC=0x40060</code>， 则PC++ 意味着 <code>0x40064</code></li><li>判断机制判断此时这个指令知否完整<ul><li>若是不完整，则获取 PC 当前指向的内存地址的指令，且让 PC 加1（意味着 PC指向下一个内存地址），直到判断指令已经完整了。</li><li>如果指令已经完整了，则对指令解码，<ul><li>如果指令中有要跳转的语句或分支、子程序，如条件句，函数，（如果是函数，需要保存当前PC 的状态，等函数运行结束后返回这个 PC状态），准备工作做完后则立刻设定 PC 为下一个要跳转过去的指令内存地址，接下来继续Fetch 后续的步骤。</li><li>如果没有跳转的指令，意味着程序将会继续顺序执行，那么 CPU 将获取当前的 PC 指向的内存指令，并将 PC++。</li></ul></li></ul></li><li>当一个指令（或许由好几个内存地址才能存下）完整获取后，PC 将进行下一步动作 或许继续加一获取 或许跳转到其他地址。</li></ul><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-18-Screen%20Shot%202018-05-18%20at%2018.08.50.png" alt=""></p><p>这样看来，由于程序指令是有顺序的，一般从上向下执行，遇到特殊指令会变化，则程序计数器一般总是加1让 CPU 获取顺序化的下一条指令；当有特殊指令，PC 会立刻变化，CPU 按照 PC 的变化后的内容获取指令。</p><h3 id="2-些许想法"><a href="#2-些许想法" class="headerlink" title="2. 些许想法"></a>2. 些许想法</h3><ul><li>32位系统的最大内存地址是 2<sup>32</sup>位，4G，其中部分给数据内存，部分给指令内存，由此即便有8G 的物理内存，4G 之外的不能被访问到。</li><li>CPU 对数据内存和指令内存 中数据和指令的获取方式不一样<br>数据和指令都存在内存中，但是存储的区域不一样，访问的方式也不一样。数据内存的地址总是开始于某个地址，指令内存的地址总是开始于另一个地址，且不会有交集；另外，数据内存中的数据必须经过寄存器再到算数逻辑单元 ALU，指令内存中的指令可以直接倒 ALU 解码。</li></ul><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><blockquote><p><a href="https://www.quora.com/What-is-the-difference-between-program-and-data-memory" target="_blank" rel="noopener">https://www.quora.com/What-is-the-difference-between-program-and-data-memory</a><br><a href="https://stackoverflow.com/questions/10876372/difference-between-memory-address-registermar-and-program-counterpc" target="_blank" rel="noopener">https://stackoverflow.com/questions/10876372/difference-between-memory-address-registermar-and-program-counterpc</a><br><a href="https://www.youtube.com/watch?v=ccf9ngGIb8c&amp;t=333s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ccf9ngGIb8c&amp;t=333s</a><br><a href="https://en.wikipedia.org/wiki/Program_counter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Program_counter</a><br><a href="https://en.wikibooks.org/wiki/Microprocessor_Design/Program_Counter" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/Microprocessor_Design/Program_Counter</a><br><a href="https://www.quora.com/What-is-program-counter-and-its-role" target="_blank" rel="noopener">https://www.quora.com/What-is-program-counter-and-its-role</a><br><a href="https://blog.csdn.net/abcjennifer/article/details/5529647" target="_blank" rel="noopener">https://blog.csdn.net/abcjennifer/article/details/5529647</a><br><a href="http://p8gbnxign.bkt.clouddn.com/ProgramCounter.pdf" target="_blank" rel="noopener">http://p8gbnxign.bkt.clouddn.com/ProgramCounter.pdf</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机底层 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac 常用命令收录</title>
      <link href="/2018/05/14/MacOS%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%B6%E5%BD%95/"/>
      <url>/2018/05/14/MacOS%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%B6%E5%BD%95/</url>
      <content type="html"><![CDATA[<p><a href="#anchor"><breathe-btn>Rolling Updating Log</breathe-btn></a> </p><h2 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h2><h3 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h3><h4 id="tree"><a href="#tree" class="headerlink" title="$ tree"></a>$ tree</h4><blockquote><p>作用：输出目录树层结构</p></blockquote><p>输出目录树 n 层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tree -L n</span><br></pre></td></tr></table></figure><a id="more"></a><p>输出目录树到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tree -L 2 &gt;README.md //然后我们看下当前目录下的 README.md 文件</span><br></pre></td></tr></table></figure><p>只显示文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tree -d -L n</span><br></pre></td></tr></table></figure><p>显示时忽略某些文件夹或文件 (Ignore)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tree -I <span class="string">"models"</span></span><br></pre></td></tr></table></figure><h2 id="系统设置类"><a href="#系统设置类" class="headerlink" title="系统设置类"></a>系统设置类</h2><h3 id="关闭系统动画效果"><a href="#关闭系统动画效果" class="headerlink" title="关闭系统动画效果"></a>关闭系统动画效果</h3><h4 id="关闭-MissionControl-动画"><a href="#关闭-MissionControl-动画" class="headerlink" title="关闭 MissionControl 动画"></a>关闭 MissionControl 动画</h4><p><code>-float</code> 后面是动画时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock expose-animation-duration -<span class="built_in">float</span> 0.0;killall Dock</span><br></pre></td></tr></table></figure></p><h4 id="关闭窗口和对话框动画"><a href="#关闭窗口和对话框动画" class="headerlink" title="关闭窗口和对话框动画"></a>关闭窗口和对话框动画</h4><p>需要注销重新登录生效, 关闭:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write -g NSAutomaticWindowAnimationEnabled -bool FALSE</span><br></pre></td></tr></table></figure></p><p>打开:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete -g NSAutomaticWindowAnimationEnabled</span><br></pre></td></tr></table></figure></p><h4 id="关闭预览动画"><a href="#关闭预览动画" class="headerlink" title="关闭预览动画"></a>关闭预览动画</h4><p>关闭:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder QLPanelAnimationDuration -int 0;killall Finder</span><br></pre></td></tr></table></figure></p><p>打开:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete com.apple.finder QLPanelAnimationDuration;killall Finder</span><br></pre></td></tr></table></figure></p><h4 id="关闭文件保存-打印的动画"><a href="#关闭文件保存-打印的动画" class="headerlink" title="关闭文件保存/打印的动画"></a>关闭文件保存/打印的动画</h4><p>需要注销后重新登录,关闭:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write -g NSWindowResizeTime -<span class="built_in">float</span> 0.01</span><br></pre></td></tr></table></figure></p><p>打开:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete -g NSWindowResizeTime</span><br></pre></td></tr></table></figure></p><h4 id="关闭-LaunchPad-动画"><a href="#关闭-LaunchPad-动画" class="headerlink" title="关闭 LaunchPad 动画"></a>关闭 LaunchPad 动画</h4><p>关闭:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-show-duration -int 0 defaults write com.apple.dock springboard-hide-duration -int 0;killall Dock</span><br></pre></td></tr></table></figure></p><p>打开:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete com.apple.dock springboard-show-duration defaults delete com.apple.dock springboard-hide-duration;killall Dock</span><br></pre></td></tr></table></figure></p><h4 id="关闭-Dock-栏动画"><a href="#关闭-Dock-栏动画" class="headerlink" title="关闭 Dock 栏动画"></a>关闭 Dock 栏动画</h4><p>关闭:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock autohide-time-moidifier -int 0;killall Dock</span><br></pre></td></tr></table></figure></p><p>打开:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock autohide-time-moidifier -int 0;killall Dock</span><br></pre></td></tr></table></figure></p><h3 id="设置-Dock-自动隐藏唤起的延迟"><a href="#设置-Dock-自动隐藏唤起的延迟" class="headerlink" title="设置 Dock 自动隐藏唤起的延迟"></a>设置 Dock 自动隐藏唤起的延迟</h3><p><a href="https://www.quora.com/How-can-I-completely-hide-or-remove-the-Dock-in-Mac-OS-X-Yosemite" target="_blank" rel="noopener">https://www.quora.com/How-can-I-completely-hide-or-remove-the-Dock-in-Mac-OS-X-Yosemite</a> 说不建议将 Dock 彻底的关掉,因为 Dock 的运行服务和系统的桌面背景等相关功能有关, 更好的方式是将 Dock 设置为自动隐藏,唤起时间加长这样就不会轻易触发.</p><p><code>-float 5</code> 是唤起的延迟时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.Dock autohide-delay -<span class="built_in">float</span> 5 &amp;&amp; killall Dock</span><br></pre></td></tr></table></figure></p><p>恢复默认的自动唤起:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete com.apple.Dock autohide-delay</span><br></pre></td></tr></table></figure></p><h3 id="限制进程的-CPU-使用率"><a href="#限制进程的-CPU-使用率" class="headerlink" title="限制进程的 CPU 使用率"></a>限制进程的 CPU 使用率</h3><p><a href="https://apple.stackexchange.com/questions/24998/can-i-manually-limit-the-cpu-used-by-a-process" target="_blank" rel="noopener">https://apple.stackexchange.com/questions/24998/can-i-manually-limit-the-cpu-used-by-a-process</a><br><a href="http://www.willnolan.com/cputhrottle/cputhrottle.html" target="_blank" rel="noopener">http://www.willnolan.com/cputhrottle/cputhrottle.html</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://github.com/herrbischoff/awesome-macos-command-line" target="_blank" rel="noopener">https://github.com/herrbischoff/awesome-macos-command-line</a><br><a href="https://www.infoworld.com/article/2614879/mac-os-x/mac-os-x-top-20-os-x-command-line-secrets-for-power-users.html?page=6" target="_blank" rel="noopener">https://www.infoworld.com/article/2614879/mac-os-x/mac-os-x-top-20-os-x-command-line-secrets-for-power-users.html?page=6</a><br><a href="https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_cmds.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_cmds.html</a></p></blockquote><p><span id="anchor"></span></p><h3 id="Rolling-Update"><a href="#Rolling-Update" class="headerlink" title="Rolling Update"></a>Rolling Update</h3><updating>2018-05-14 09:47:59 Update:  增加设置 Dock 自动隐藏唤起时间设置</updating><br><updating>2018-05-13 20:09:32 Update:  增加关闭动画命令</updating>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令行工具 </tag>
            
            <tag> 持续更新 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统-3 | 4 章</title>
      <link href="/2018/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_3_4/"/>
      <url>/2018/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_3_4/</url>
      <content type="html"><![CDATA[<h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><h3 id="“差不多”精神"><a href="#“差不多”精神" class="headerlink" title="“差不多”精神"></a>“差不多”精神</h3><p>操作系统是人造科学，其中蕴含着“差不多”的思想，学习操作系统不可吹毛求疵。</p><h3 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h3><h4 id="概念上的结构："><a href="#概念上的结构：" class="headerlink" title="概念上的结构："></a>概念上的结构：</h4><ul><li>一条总线，各种硬件挂在这根总线上；而每个硬件都是通过对应的控制器连接到总线与 CPU 通信。<br><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-09-121639.png" alt=""><a id="more"></a></li><li>流水线是结构：为了提高效率，模仿工业流水线结构，即每一级都在工作，但是每一级的工作内容都不一样，呈时序关系。<br><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-09-122102.png" alt=""></li><li>执行单元：缓存是让执行单元发挥最大利用效率的结构。<br><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-09-122246.png" alt=""></li><li>存储结构：金字塔形，容量在增大，价格在降低；容量在增大，速度在减小。<br><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-09-122428.png" alt=""></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7" target="_blank" rel="noopener">中断</a>：OS 中最重要的机制，是 OS 获取PC 控制权的根本保证。<br><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-09-123138.png" alt=""></li></ul><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><ul><li>根本上存在但是现实中不存在。</li><li>来源于现实，统一于现实，超出现实。</li><li>操作系统的抽象在于它来源于硬件，但超出了简单将硬件相叠加的功能，为上层应用提供了更大的资源。</li><li>软件中不同功能块之间也是一种抽象，对其他功能块而言是一个完整的功能，而非细节描述。</li></ul><h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><ul><li>内核态<br>拥有最多资源，最高特权。管理 CPU、内存、诊断测试、部分文件系统。</li><li>用户态<br>拥有有限的资源，有限的权限。应用程序的管理。</li><li>状态的识别<br>CPU 的状态字的设定，在一个程序运行时，此时 CPU 设定的什么状态这个程序就工作在什么态。</li><li>实现<br>这种两个状态相分离的实现，是通过“地址翻译”来实现，对用户态下的程序的每一条指令都会检查；而内核态下的程序可以绕过这个翻译。 这是否就为病毒提供可获取最高特权的可能？</li></ul><h4 id="操作系统的结构演变"><a href="#操作系统的结构演变" class="headerlink" title="操作系统的结构演变"></a>操作系统的结构演变</h4><h2 id=""><a href="#" class="headerlink" title=""></a><div id="flowchart-0" class="flow-chart"></div></h2><p>微内核操作系统结构：<br><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-09-130416.png" alt=""></p><h4 id="进程、内存、文件"><a href="#进程、内存、文件" class="headerlink" title="进程、内存、文件"></a>进程、内存、文件</h4><ul><li>进程 - 在运行中的程序</li><li>内存 - 进程的存放场所</li><li>文件 - 程序和数据的最终存放点</li></ul><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li>操作系统是通过系统调用来为应用程序提高服务的。应用程序通过调用操作系统提供 的API来获得操作系统的服务。</li><li>编译器对一个程序语句先将库函数扩展为系统调用函数，再继续执行。</li><li>系统调用的种类<ul><li>进程类</li><li>文件类</li><li>设备类</li><li>内存类</li><li>信息维护类</li><li>通信类</li></ul></li><li>系统调用的3个阶段<ul><li>参数准备，将参数放入寄存器或者压入栈</li><li>调用识别，通过查询系统调用表或者系统调用函数的内存地址</li><li>调用执行，执行这个内存地址的系统调用代码</li></ul></li></ul><h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><ul><li>系统 API 过于复杂，是给专门的编程人员使用。而这个 Shell(壳) 就像是操作系统之上的一层壳，有固定的命令或图形操作方式给用户使用；用户可以通过这个 Shell 中的命令来调用系统服务，（固定的命令保证了用户不能直接使用用户态的核心服务，而是有界限的只用 Shell 提供的这些，保证了系统安全）。</li><li>一个 Shell 就是一个循环程序，始终在等待用户的输入，当用户输入后程序继续执行并 fork 一个子进程来完成用户的命令任务，父进程等待子进程结束。</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><p><strong>进程</strong> 是正在运行中的程序，是对程序的抽象。也就是说，进程根本上是存在的，是人为定义的，但是物理意义上是不存在的，是抽象出来描述运行中程序的一个概念。</p><h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-11-161534.png" alt=""></p><h4 id="进程带来的好处"><a href="#进程带来的好处" class="headerlink" title="进程带来的好处"></a>进程带来的好处</h4><ul><li>进程的发明让正在运行的程序的具体细节对用户而言是透明的,</li><li>用户可以同时运行多个程序,并相对串行运行的程序而言可以更快的给出响应,降低了平均响应时间.</li><li>极大的提高了 CPU 的效率</li></ul><h3 id="进程创立-产生-消失"><a href="#进程创立-产生-消失" class="headerlink" title="进程创立/产生/消失"></a>进程创立/产生/消失</h3><h4 id="进程创立"><a href="#进程创立" class="headerlink" title="进程创立"></a>进程创立</h4><p>进程的创立需要 <code>分配进程控制块</code> -&gt; <code>初始化机器寄存器</code> -&gt; <code>初始化页表</code> -&gt; <code>程序读入内存</code> -&gt; <code>CPU 设置为 用户态</code> -&gt; <code>跳转到程序执行的起始地址</code>  </p><ul><li>Unix下<ul><li>第一步: <code>fork</code>   A进程fork 一个与自己完全一样的进程B,</li><li>第二步: <code>exec</code>  将 B 进程的地址空间用待要启动的程序内容来覆盖, 跳转到这个新程序的起始地址,开始exec</li></ul></li><li>Windows 下<br>没有fork 这个步骤,直接由系统调用来产生新的进程  </li><li>地址空间<ul><li><a href="https://en.wikipedia.org/wiki/Virtual_address_space" target="_blank" rel="noopener">地址空间</a>是进程执行的内存空间, 是进程执行的舞台,包含进程执行要用到的所有资源</li><li>地址空间只是提供资源,真正使用这些资源的叫做<code>线程</code>,舞台上的演员. </li><li>进程就是这场舞台剧</li></ul></li></ul><h4 id="进程的产生"><a href="#进程的产生" class="headerlink" title="进程的产生"></a>进程的产生</h4><p>进程可以看做有多种类型, 系统进程/用户进程.</p><ul><li>系统初始化 -&gt; 人类的诞生</li><li>系统进程创建新的子程序,可以看做是操作系统自然产生的 -&gt; 人类自然繁衍的孩子</li><li>用户请求创建的新进程可以看做是用户人为创造的 -&gt; 就像试管婴儿.</li><li>然后子进程可能又会不断的产生新的进程.</li></ul><h4 id="进程的消失"><a href="#进程的消失" class="headerlink" title="进程的消失"></a>进程的消失</h4><p>进程的终止可以有下面几个原因:</p><ul><li>寿终:   进程完成任务后自然的退出结束.</li><li>自杀:   进程自身发生错误, 退出结束. </li><li>他杀:   被其他进程强行杀死</li><li>处决:   进程产生异常, 被系统强制终结</li></ul><h3 id="进程的层次与状态"><a href="#进程的层次与状态" class="headerlink" title="进程的层次与状态"></a>进程的层次与状态</h3><h4 id="进程的层次"><a href="#进程的层次" class="headerlink" title="进程的层次"></a>进程的层次</h4><p>进程的层次:用户层/内核层<br>一个进程在执行过程中可以通过系统调用来产生新的进程, 新的进程叫做 子进程, 原来的进程就是它的 父进程.  在 Unix 系统中有父进程和子进程的概念.<br>在 WIndows 系统中不存在这种概念,认为所有的进程地位是平等的.</p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p><code>执行</code> – <code>就绪</code> – <code>阻塞</code></p><ul><li>执行 -&gt; 就绪<br>CPU 在<code>执行</code>A 进程的过程中, 考虑资源平均的因素, 自然切换到了B进程. 此时 A 进程进入到<code>就绪</code>状态,等待 CPU 的再一次执行.</li><li>执行 -&gt; 阻塞<br> CPU 在<code>执行</code> A 进程的过程中, 遇到需要 I/O 操作,此时 CPU 切换到其他进程, A 进程进入<code>阻塞</code>状态</li><li>就绪 -&gt; 执行<br>A 进程一直在等待 CPU 在选择它来执行,一旦 CPU 选择了 A 程序, A 程序由<code>就绪</code>进入<code>执行</code></li><li>阻塞 -&gt; 就绪<br>A 进程在处理完 I/O 后,解除阻塞状态,等待 CPU 选择执行,此时正是处于<code>就绪</code>状态</li></ul><p><strong>特别的</strong> : </p><ul><li><p>不存在 阻塞-&gt; 执行 这个过程<br>因为阻塞到执行中间必须经过<code>就绪</code>状态,  这是实际上可以操作的,但是阻塞在未进入就绪状态时由被 CPU 选择执行还是阻塞状态,这是没有意义的.</p></li><li><p>不存在 就绪 - &gt; 阻塞<br>因为一个处于阻塞状态下的进程, 等待它的下一步操作必然是 CPU 来执行它,只有再执行后才会遇到 I/O 操作,进入到<code>阻塞</code>状态.  这是逻辑上行不通的.<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr8l0k4dnej30ki0dydiz.jpg" alt=""></p></li><li><p>一个进程的生命周期</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-115827.png" alt=""></p></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul><li><p>维护进程记录<br>使用<code>进程表</code>,其中包括每个进程使用的<code>寄存器,程序计数器,状态字,栈指针,优先级,进程的 ID,创建时间,使用 CPU 时间</code>,等信息. 有些进程处于用户态,但进程表都在内核态.<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr8l1kmbz7j30sa0hmq6l.jpg" alt=""></p></li><li><p>进程控制块，每个进程都有一个进程控制块，可以看做各个进程控制块构成了进程表。</p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-20-115532.png" alt="进程控制块，涵盖一个进程的所有信息"></p></li><li><p>进程在同一个时间只能干一件事情, 公平与效率,如何设置优先级都是总要的.</p></li><li><p>线程的引入将会解决 同一时间只能做一件事的问题 和 整个进程都会被阻塞的问题(意味着进程中不宜懒于I/O 的部分也不能被执行推进,让整个进程的每一部分都停滞)<br><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: 网状结构，各个功能模块之间错综复杂op2=>operation: 层次结构，将用户态和内核态分开，系统服务都在内核态，这增加了从用户态向内核态之间过渡的时间成本op3=>operation: 微内核结构，将核心服务留在内核态，其他的系统服务放在用户态。现在主流。op1->op2->op3</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p></li></ul>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Search Tricks</title>
      <link href="/2018/05/12/Google%20Search%20Tricks/"/>
      <url>/2018/05/12/Google%20Search%20Tricks/</url>
      <content type="html"><![CDATA[<p><span style="color:red"><em> 2018-05-12 09:58:35 Update: </em></span></p><p>采用多种搜索方式的组合，提高搜索效率。（面向 Google 编程？emmm…）</p><h3 id="搜索遵照的原则"><a href="#搜索遵照的原则" class="headerlink" title="搜索遵照的原则"></a>搜索遵照的原则</h3><ul><li>搜索的”句法”范围从宽泛到具体<br>这样往往会包含到你需要的所有信息, 一开始的具体搜索并不是个好习惯, 因为你想要的信息网页上的提供者可能不是按照你需要的那样描述的, 一开始键入 <strong>关键词</strong> 可以覆盖的更多的信息.</li><li>尝试用另一种表述<br>用一种单一的表述来搜索可能不能找到你需要的信息, 尝试换一种表述来表达同样的意思.<a id="more"></a></li><li>使用标签<br>当你明确搜索的是图片或者视频，就选择相应的标签。</li></ul><h3 id="常用的搜索技巧"><a href="#常用的搜索技巧" class="headerlink" title="常用的搜索技巧"></a>常用的搜索技巧</h3><ul><li>用加号减号<ul><li>加号，<code>+</code> 意味着前后单词或句子必须同时出现在搜索结果中。如：<code>Syntax +Python3</code> 注意：<code>+</code> 前面有空格，后面没有空格，必须严格遵照搜索语法，否则是起不到效果的。<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fr8e4tgxl5j30z00ledm2.jpg" alt=""></li><li>减号，<code>-</code> 意味着前面的搜索结果中必然不能包含后面的单词或句子。如： <code>Programming -Windows</code> 注意：同样的，<code>-</code> 前面有空格后面没有空格。</li></ul></li><li>使用双引号来限定精确搜索</li></ul><p>用 <code>&quot;Python syntax&quot;</code> 来表示搜索结果中必须包含 “Python syntax” 这样的短语，不能是其他含有 Python 或者 syntax 的搜索结果。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fr8e6gpzkpj311y0ucwof.jpg" alt=""></p><ul><li>使用 <code>OR</code> 搜索 / 使用 <code>AND</code> 搜索<ul><li><code>Python OR Java</code> 结果中出现 Java 或者 Python，但不同时出现。<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr8e78wvjgj30xo0isjw8.jpg" alt=""></li><li><code>Python AND Java</code>，结果中同时包含Java 和 Python<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fr8e7r8m7gj310c0vok03.jpg" alt=""></li></ul></li><li>限定搜索的网站<br>使用冒号 <code>:</code> 来限定搜索的网站，如：<code>python site:github.com</code> 表示在 github 中搜索 python 相关的信息。<ul><li>注意若限定的网址前缀不是<code>www</code>，必须将网址补全。</li><li><code>site:</code> 冒号后面不能有空格。<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fr8e8m7z5mj30xo0ladlr.jpg" alt=""></li></ul></li><li>使用通配符模糊查找<br><code>*</code> 表示任意单词或句子。<code>“Come * right now * me”</code> 将包含各种视 <code>*</code> 为任意单词/句子的结果。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fr8e9w8w52j30y80neti0.jpg" alt=""></li><li>搜索结果是包含某种特定的文件类型<br><code>&quot;python cookbook&quot; filetype:pdf</code>  搜索结果全是 pdf 文件类型,且包含 python cookbook 这个短语<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fr8eagp2ntj30xu0mc7aq.jpg" alt=""></li></ul><h3 id="限定在标题-文章中查找"><a href="#限定在标题-文章中查找" class="headerlink" title="限定在标题/文章中查找"></a>限定在标题/文章中查找</h3><ul><li>需要的关心的在网页 <strong>标题</strong>中，不管其他地方如网页文章内容中<ul><li><code>allintitle:android AND iOS</code> 显示的搜索结果中的标题中必然都同时包含 andriod 和 IOS , 不区分大小写。<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr8eb5epssj310o0ne79e.jpg" alt=""></li><li>相对弱化精确度的是：<code>intitle:android AND IOS</code> 结果并不是精确的包含冒号后的句法，文章中可以有, 这是相对更广泛的搜索。</li></ul></li><li>需要的关心的信息在网页文章内容中，不管其他地方<ul><li><code>allintext:android AND iOS</code> 显示的搜索结果只在文章中含有,标题中没有<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr8ebtobsmj310i0nmted.jpg" alt=""></li><li><code>intext:android AND iOS</code> 显示网页文章中包含冒号后句法的搜索结果,标题中可以有, 搜索结果相对更广泛.</li></ul></li><li>与常用查找的组合<br><code>&quot;neil diamond&quot; intext:&quot;red sox&quot;</code> 意思是: 在我们要搜索的关于neil diamond 结果中, 同时在文章内容中要包含 red sox 这个短语.<br><code>python learning intitle:advice</code> 意思是: 在我们要搜索的关于 python learning 结果中,同时要在文章标题中包含 advice 这个词<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fr8ed65eq6j30y20i4doz.jpg" alt=""></li></ul><h3 id="与网址相关的查找"><a href="#与网址相关的查找" class="headerlink" title="与网址相关的查找"></a>与网址相关的查找</h3><ul><li>需要的关心的信息在网址中<br><code>inurl:photoshop</code> 搜索结果中，网页的网址都会包含冒号后的句法。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fr8edsc3wzj30xm0kqwk4.jpg" alt=""></li><li>搜索 引用了某个特点网址 所有网页<br><code>link:www.baidu.com</code> 搜索结果中都是在网页中有引用 <code>www.baidu.com</code> 这个链接。</li><li>查找 和某个网站相似 的网站<br><code>related:amazon.com</code> 列出所有的在线销售网站<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr8eecywwrj30ye0g4dk3.jpg" alt=""></li></ul><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><ul><li>使用数字的范围<br><code>40..50 +&quot;python code&quot;</code> 显示的结果中包含 40至50的数字 和 python code 这个短语.<br><code>president 1920..1950</code> 显示在这个时间段内的 关于president 的信息，会用加粗来表示<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr8ef6v8pwj30yk0m4qa6.jpg" alt=""></li><li>查找单词的定义<br><code>Define:fancy</code> 将给出fancy 这个单词的意思, 默认是英文定义<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fr8eg9luhqj310a13q45d.jpg" alt=""><br><code>chinese define:fancy</code> 给出中文意思<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fr8ehepsjlj30ye0c4gpz.jpg" alt=""><br><code>cambridge chinese: fancy</code> 在第一条给出剑桥词典意思, 很好的词典.<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fr8ei286vpj3178146ags.jpg" alt=""></li></ul>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geek 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim 配置与使用</title>
      <link href="/2018/05/11/Vim%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/05/11/Vim%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><span style="color:red"><em> 2018-05-11 23:38:33 Update: </em></span></p><h2 id="Vim-安装时"><a href="#Vim-安装时" class="headerlink" title="Vim 安装时"></a>Vim 安装时</h2><p> Mac 环境下，Vim 在安装之前就应该想好要用到支持哪些语言的编译，否则在安装好后需要某个插件时但是之前没有支持编译再重新安装 Vim 会很麻烦。且对应的 python 的版本号要注意。   </p><p> 注意： <code>Neocomplete</code> 需要 <code>lua</code> , <code>YouCompleteMe</code> 需要 <code>python</code> 。</p><a id="more"></a><h2 id="Vim-插件"><a href="#Vim-插件" class="headerlink" title="Vim 插件"></a>Vim 插件</h2><p>目前使用的是 Vimplus 这个模板。YouCompleteMe 没有安装。在任意文字的补全时不太友好。</p><ul><li>目前在使用的插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class="line">Plugin &apos;L9&apos;</span><br><span class="line">Plugin &apos;chxuan/change-colorscheme&apos;</span><br><span class="line">Plugin &apos;Yggdroot/indentLine&apos;</span><br><span class="line">Plugin &apos;easymotion/vim-easymotion&apos;</span><br><span class="line">Plugin &apos;haya14busa/incsearch.vim&apos;</span><br><span class="line">Plugin &apos;wsdjeg/FlyGrep.vim&apos;</span><br><span class="line">Plugin &apos;iamcco/mathjax-support-for-mkdp&apos;</span><br><span class="line">Plugin &apos;iamcco/markdown-preview.vim&apos;</span><br><span class="line">Plugin &apos;jiangmiao/auto-pairs&apos;</span><br><span class="line">Plugin &apos;scrooloose/nerdcommenter&apos;</span><br><span class="line">Plugin &apos;scrooloose/nerdtree&apos;</span><br><span class="line">Plugin &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;</span><br><span class="line">Plugin &apos;rkulla/pydiction&apos;</span><br><span class="line">Plugin &apos;Valloric/MatchTagAlways&apos;</span><br><span class="line">&quot;Plugin &apos;Valloric/YouCompleteMe&apos;</span><br><span class="line">Plugin &apos;davidhalter/jedi-vim&apos;</span><br><span class="line">Plugin &apos;docunext/closetag.vim&apos;</span><br><span class="line">Plugin &apos;godlygeek/tabular&apos;</span><br><span class="line">Plugin &apos;tpope/vim-fugitive&apos;</span><br><span class="line">Plugin &apos;tpope/vim-surround&apos;</span><br><span class="line">Plugin &apos;tpope/vim-commentary&apos;</span><br><span class="line">Plugin &apos;tpope/vim-repeat&apos;</span><br><span class="line">Plugin &apos;tpope/vim-endwise&apos;</span><br><span class="line">Plugin &apos;ctrlpvim/ctrlp.vim&apos;</span><br><span class="line">Plugin &apos;majutsushi/tagbar&apos;</span><br><span class="line">Plugin &apos;octol/vim-cpp-enhanced-highlight&apos;</span><br><span class="line">Plugin &apos;vim-airline/vim-airline&apos;</span><br><span class="line">Plugin &apos;vim-airline/vim-airline-themes&apos;</span><br><span class="line">Plugin &apos;vim-scripts/a.vim&apos;</span><br><span class="line">Plugin &apos;vim-scripts/DoxygenToolkit.vim&apos;</span><br><span class="line">Plugin &apos;vim-scripts/txt.vim&apos;</span><br><span class="line">Plugin &apos;ryanoasis/vim-devicons&apos;</span><br><span class="line">Plugin &apos;gorodinskiy/vim-coloresque&apos;</span><br><span class="line">Plugin &apos;will132/vim-dirdiff&apos;</span><br><span class="line">Plugin &apos;mhinz/vim-startify&apos;</span><br><span class="line">Plugin &apos;junegunn/vim-slash&apos;</span><br><span class="line">Plugin &apos;chrisbra/csv.vim&apos;</span><br><span class="line">Plugin &apos;vim-syntastic/syntastic&apos;</span><br><span class="line">Plugin &apos;edkolev/promptline.vim&apos;</span><br><span class="line">Plugin &apos;edkolev/tmuxline.vim&apos;</span><br><span class="line">Plugin &apos;christoomey/vim-tmux-navigator&apos;</span><br><span class="line">Plugin &apos;joker1007/vim-markdown-quote-syntax&apos;</span><br><span class="line">Plugin &apos;gabrielelana/vim-markdown&apos;</span><br><span class="line">Plugin &apos;lvht/tagbar-markdown&apos;</span><br><span class="line">Plugin &apos;mileszs/ack.vim&apos;</span><br></pre></td></tr></table></figure><ul><li>完整配置 .vimrc</li></ul><p><a href="">.vimrc</a></p>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习是过程而非目的</title>
      <link href="/2018/05/11/%E5%AD%A6%E4%B9%A0%E6%98%AF%E8%BF%87%E7%A8%8B%E8%80%8C%E9%9D%9E%E7%9B%AE%E7%9A%84/"/>
      <url>/2018/05/11/%E5%AD%A6%E4%B9%A0%E6%98%AF%E8%BF%87%E7%A8%8B%E8%80%8C%E9%9D%9E%E7%9B%AE%E7%9A%84/</url>
      <content type="html"><![CDATA[<h3 id="学习是手段"><a href="#学习是手段" class="headerlink" title="学习是手段"></a>学习是手段</h3><p>今天看到一篇文章，作者讲述了他研究生毕业后才发现之前对待学习的态度都是将学习作为任务、作为目标去完成，而今才发现学习本不是这样，它是一个过程。   </p><p>我们有时会为自己学习而感动，把每天学习了多长时间、学习了多少知识作为一种衡量标准，这种想法的结果是我们有时甚至连 <strong>学习</strong> 这件事都做不到，因为各种事情没有去学习，没有去做到这个目标。   </p><a id="more"></a><p>我们会逐渐的麻痹自己，以为自己坐下来看了很长时间的书、写了很多题目就会让自己增长能力，然而学习并不是判定的标准，我们的目的是提升我们的大脑，提升思维的方式，丰富知识体系，这是一项工程，思维与知识记忆逐步的变强大。</p><h3 id="提升思维体系是目的"><a href="#提升思维体系是目的" class="headerlink" title="提升思维体系是目的"></a>提升思维体系是目的</h3><p>尝试反问自己通过学习我得到了什么？   </p><p>尝试感受到自己思维体系在丰富！   </p><p>尝试再输出，再输入的去感受思维的力量！</p>]]></content>
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统-1 | 2 章</title>
      <link href="/2018/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_1_2/"/>
      <url>/2018/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_1_2/</url>
      <content type="html"><![CDATA[<h2 id="1，2章"><a href="#1，2章" class="headerlink" title="1，2章"></a>1，2章</h2><h3 id="人造科学"><a href="#人造科学" class="headerlink" title="人造科学"></a>人造科学</h3><p>学习一门学科要用对应的思维模式，也是一种哲学。<br>作者反复强调一种观点：计算机科学不同于自然科学的发现，它是本来不存在的，是人类的发明，是人造的科学，人造的科学带有一定的不确定性，这并不像自然科学那样有着严格的数学意义和严谨的数学推理。既然是人为的科学便有种“差不多”式的学问在里面。对这点的理解可以结合算法的分析来看，算法的复杂的往往只是用它的最高阶来表示，大O记号来表示，这就不考虑那些低阶表达式的影响。在人造科学的学习上，逻辑关系的理解比细节的具体的量化信息更为重要。我们不能说一个程序一定没有Bug，而这个Bug有可能是逻辑的错误，有可能是计算机本身的数据的不精确产生。<br>人造科学的特点：<br><a id="more"></a></p><ul><li>不精确、有相对性 <code>没有严格的对错</code></li><li>从人类的活动观察导出 <code>来源于对人类活动的观察，如栈与队列和人类的排队</code></li><li>依赖于人的主观判断力 <code>多数人认同的抽象成为标准</code></li><li>通常符合人的直觉，相比于自然科学常常是不能为直觉所感受的 <code>许多原理和人的直觉直接呼应</code></li></ul><p>自然科学的特点：</p><ul><li>精确，绝对</li><li>从对自然的观察中导出</li><li>不依赖于人的主观判断</li><li>通常不符合人的直觉</li></ul><h3 id="Operating-System-是什么"><a href="#Operating-System-是什么" class="headerlink" title="Operating System 是什么"></a>Operating System 是什么</h3><p><code>Operating System</code> – 应该理解为“掌控计算机的系统”，它并不是在操作，而是掌握了了计算机中的发生的一切事情。是介于计算机硬件和应用程序之间的一个软件系统。当一个未经操作系统允许的行为产生，这被视为是非法的事情。但人们设计的系统不会十全十美，总有缺陷这给攻击者可乘之机。  </p><p>操作系统的角色：魔术师，管理者。前者表现在它将硬件资源以抽象的、独占式的方式呈现给用户；后者体现在它管理者计算机中的一切事物的发生。根据管理的资源不同操作系统分为以下四种管理方式，将每种资源分配给不同的应用程序和用户。</p><ul><li>CPU 管理</li><li>内存管理</li><li>外部存储管理</li><li>I/O 管理</li></ul><h3 id="操作系统的演变"><a href="#操作系统的演变" class="headerlink" title="操作系统的演变"></a>操作系统的演变</h3><p>状态机操作系统： 简单版的计算器，无存储功能<br><code>-&gt;</code><br>单一控制端操作系统：一次只能执行一个命令，机器等人输入命令<br><code>-&gt;</code><br>单道批处理系统：管理员统一管理，管理员集中将命令写入磁带，将磁带放入系统运行，机器等人装载磁带<br><code>-&gt;</code><br>多道批处理系统：管理员统一管理，将 CPU 运行与输入输出重叠，在一个程序输入输入时，另一个程序在继续占用 CPU   执行。这是划时代的系统，已经有了并发的概念。<br><code>-&gt;</code><br>分时操作系统：多个用户共享一台计算机资源，用户直接进行程序指令的输入，用户有独占感，”随时”与计算机交互，相比于多道批处理系统将操作系统的资源分配的更公平。同时带来了竞争、死锁、保护、进程的概念和问题。<br><code>-&gt;</code><br>实时操作系统，不是指立刻响应，而是能在规定时间内完成特定功能，否则就可能是整个系统出错。所有任务必须满足“时序可预见性”。最重要的部分在于工作调度和进程。必须精确的使得任务在可接受的时间内完成。分为软实时系统与硬实时系统。<br><code>-&gt;</code><br>现代操作系统，分布式操作系统。   </p><p>总的来看，操作系统的进化，一方面是硬件技术如内存，CPU 性能提高后增加任务复杂度的结果；另一方面是竟可能的利用计算机硬件资源不断优化的结果。   </p><p><img src="http://p8gbnxign.bkt.clouddn.com/blog/2018-05-09-Screen%20Shot%202018-05-09%20at%20185311.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初探前端编程的结构</title>
      <link href="/2018/05/08/%E5%88%9D%E6%8E%A2%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84/"/>
      <url>/2018/05/08/%E5%88%9D%E6%8E%A2%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>在捣鼓博客主题源码中学习！</p><blockquote><p>—2018-05-08 22:08:00—</p></blockquote><p>今晚又研究了Hexo 框架前端结构，尝试通过给 Hexo Landscape-plus 主题加上本地搜索的功能。  </p><p>在主题源码中发现 ejs 和 js 的层层调用关系，并将 css 与 js 联系起来，用 css 来修饰 js 中的元素（id，form，div）。  </p><p>尝试将 Yelee 主题的本地搜索源码移植到 Landscape-plus 主题上代替其自带的百度搜索的功能，主要将其中的对搜索框的修饰代码和搜索动作搜索结果的呈现这些 js 代码嵌入进去。  </p><p>其中疑惑的几点：</p><ul><li>pc.js 调用 <code>search.js</code> 产生的新的 <code>search</code> 函数没有被其他代码直接调用，而是用了一个其中的 <code>resertSearch</code> 的函数，暂时理解为调用 <code>resertSearch</code> 函数会自动加载前面的部分，实现了调用。有待确认。</li><li>最后编译本地调试后发现搜索框存在，但是并不能完成搜索的功能，这让我很不解，可能还有部分代码移植的有问题。</li></ul><p>暂时还是先用 Yelee 的主题写博客，以上工作的代码已经备份到 coding.net 。</p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>元启发式算法</title>
      <link href="/2018/05/07/%E5%85%83%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/05/07/%E5%85%83%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="i-什么是元启发式算法"><a href="#i-什么是元启发式算法" class="headerlink" title="i.什么是元启发式算法"></a>i.什么是元启发式算法</h2><h3 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h3><ul><li>启发式算法(Heuristic Algorigthm)是一种基于 <strong>直观或经验</strong> 构造的算法, 并没有严格的数学证明过程，在可接受的花费(指计算时间、计算空间等)给出待解决优化问题的每一实例的一个可行解，该可行解与与最优解的偏离程度一般不可以事先预计。</li><li>意味着启发式算法可以在可接受的计算费用内找到最好的解,但不一定能保证所得到解的可行性及最优性，甚至大多数情况下无法阐述所得解与最优解之间的近似程度。例如它常能发现很不错的解，但也没办法证明它不会得到较坏的解；它通常可在合理时间解出答案，但也没办法知道它是否每次都可以这样的速度求解。</li></ul><a id="more"></a><ul><li>有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据结构，也许永远不会在现实世界出现。因此现实世界中启发式算法很常用来解决问题。启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案。</li><li>启发式算法会在其过程成采用某种机制逐步的选择使得局部最优情况的当前解，通过这种机制不断的剪枝，即 <strong>降低分叉率</strong> 以相比与暴力解法而改进搜索效率。</li></ul><h3 id="元启发式算法"><a href="#元启发式算法" class="headerlink" title="元启发式算法"></a>元启发式算法</h3><p>元启发式算法(Metaheuristic Algorithm)是启发式算法的改进，通过随机算法结合启发式算法使得其在每次迭代中能够有一定的概率跳出局部最优解逐步靠近全局最优解。在某个节点上的局部最优解不一定包含在全局最优解中，在很多元启发式算法中都是通过 <strong>轮盘转法</strong> 来做出随机选择。</p><h2 id="ii-常见算法种类"><a href="#ii-常见算法种类" class="headerlink" title="ii.常见算法种类"></a>ii.常见算法种类</h2><p>这里只是列举种类，具体的每种算法的原理和实现将由单个文章说明。</p><h3 id="启发式算法-1"><a href="#启发式算法-1" class="headerlink" title="启发式算法"></a>启发式算法</h3><ul><li>贪婪算法</li><li>爬山法</li><li>蒙特卡洛树搜索算法</li><li>萤火虫算法</li></ul><h3 id="元启发式算法-1"><a href="#元启发式算法-1" class="headerlink" title="元启发式算法"></a>元启发式算法</h3><p><a href="https://github.com/forAllBright/metaheuristic_algorithm" target="_blank" rel="noopener">Github项目</a></p><ul><li>模拟退火算法</li><li>蚁群算法</li><li>遗传算法</li><li>禁忌搜索</li><li>蝙蝠算法</li></ul><h2 id="iii-对元启发式算法的认识"><a href="#iii-对元启发式算法的认识" class="headerlink" title="iii.对元启发式算法的认识"></a>iii.对元启发式算法的认识</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>随机的初始可行解</li><li>在邻域产生新的可行解</li><li>用使得局部最优的评价函数来剪枝</li><li>随机算法选择和接受</li><li>收敛因子</li><li>有限的迭代次数</li></ul><h3 id="不完善的地方"><a href="#不完善的地方" class="headerlink" title="不完善的地方"></a>不完善的地方</h3><ul><li>启发式算法目前缺乏统一、完整的理论体系。</li><li>由于<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E8%A4%87%E9%9B%9C%E6%80%A7%E7%90%86%E8%AB%96" target="_blank" rel="noopener">NP理论</a>，各种启发式算法都不可避免的遭遇到局部最优的问题，如何判断。</li><li>各种启发式算法都有个自优点如何，完美结合。有很多的混合算法效果不错。</li><li>启发式算法中的参数对算法的效果起着至关重要的作用，如何有效设置参数。</li><li>启发算法缺乏有效的迭代停止条件。通常式认为的设定迭代次数或者迭代影响因子的下限。</li><li>启发式算法收敛速度的研究等。</li></ul><h2 id="iiii-参考"><a href="#iiii-参考" class="headerlink" title="iiii.参考"></a>iiii.参考</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元启发式算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google收录博客</title>
      <link href="/2018/05/07/Google%E6%94%B6%E5%BD%95%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/05/07/Google%E6%94%B6%E5%BD%95%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>本博客基于 Hexo 框架，目前使用 <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a> 主题，现在基本可以使用了。这里记录一下如何将博客添加到 Google 索引。</p><h2 id="Google-Search-Console"><a href="#Google-Search-Console" class="headerlink" title="Google Search Console"></a>Google Search Console</h2><p>这里只是简单介绍一下 Search Console，并不做深入的了解。</p><h3 id="什么是-Google-Search-Console"><a href="#什么是-Google-Search-Console" class="headerlink" title="什么是 Google Search Console"></a>什么是 Google Search Console</h3><a id="more"></a><p>这是 Google 开发的免费的 <a href="https://en.wikipedia.org/wiki/Search_engine_optimization" target="_blank" rel="noopener">SEO</a> 工具，可帮助您监控和维护自己网站在 Google 搜索结果中的显示情况。您无需注册 Search Console，您的网站也可以出现在 Google 搜索结果中，但注册有助于您了解 Google 如何找到您的网站并优化其在搜索结果中的显示效果。</p><p><a href="https://support.google.com/webmasters/answer/4559176?hl=zh-Hans" target="_blank" rel="noopener">https://support.google.com/webmasters/answer/4559176?hl=zh-Hans</a></p><h3 id="使用-Google-Search-Console-来收录博客"><a href="#使用-Google-Search-Console-来收录博客" class="headerlink" title="使用 Google Search Console 来收录博客"></a>使用 Google Search Console 来收录博客</h3><p><a href="https://jactor-sue.github.io/how-githubio-blog-can-be-searched-by-google/" target="_blank" rel="noopener">这篇博文讲的很详细</a></p><h3 id="验证是否已经收录"><a href="#验证是否已经收录" class="headerlink" title="验证是否已经收录"></a>验证是否已经收录</h3><p>在 Google 键入<code>site:https://xxxx.github.io/</code>，如果出现了博客的信息说明已经收录，否则说明没有收录。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.google.com/webmasters/tools/site-message-view?hl=en&amp;authuser=0&amp;siteUrl=https://forallbright.github.io/&amp;message-filter=all&amp;grid.r=0&amp;msgid=AB9YKzIyLwiIEgERX6JzhvA_AIa_DJroAoTPPDws2S8PPaBdDFd3WkoaSBnY3CAjY8Dz49VsU1v7peM_ceJ6mzi-hIMEaeT3cA" target="_blank" rel="noopener"> Improve the search presence</a><br><a href="http://www.yesharris.com/search-console-intro/" target="_blank" rel="noopener">http://www.yesharris.com/search-console-intro/</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工具类网址收录</title>
      <link href="/2018/05/06/%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95/"/>
      <url>/2018/05/06/%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95/</url>
      <content type="html"><![CDATA[<p><a href="#anchor"><breathe-btn>Rolling Updating Log</breathe-btn></a> </p><h3 id="转换类"><a href="#转换类" class="headerlink" title="转换类"></a>转换类</h3><h4 id="前端在线工具"><a href="#前端在线工具" class="headerlink" title="前端在线工具"></a>前端在线工具</h4><p>颜色RGBA-HEX，图片格式-base64，文字编码转换， HTML 特殊符号对照表。。。等<br><a href="https://www.css-js.com/tools/rgba.html" target="_blank" rel="noopener">https://www.css-js.com/tools/rgba.html</a></p><a id="more"></a><h4 id="文档格式转换工具"><a href="#文档格式转换工具" class="headerlink" title="文档格式转换工具"></a>文档格式转换工具</h4><p>pdf 的拆分合并剪裁等功能; 与 Word,mobi 等格式的互转.<br><a href="https://pdfcandy.com/tw/" target="_blank" rel="noopener">https://pdfcandy.com/tw/</a></p><h3 id="资源类"><a href="#资源类" class="headerlink" title="资源类"></a>资源类</h3><h4 id="免费开源文档"><a href="#免费开源文档" class="headerlink" title="免费开源文档"></a>免费开源文档</h4><p>开源技术文档平台,阅读体验较好.<br><a href="https://love2.io/" target="_blank" rel="noopener">https://love2.io/</a></p><p><span id="anchor"></span></p><h3 id="Rolling-Update"><a href="#Rolling-Update" class="headerlink" title="Rolling Update"></a>Rolling Update</h3><p>…</p>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续更新 </tag>
            
            <tag> 在线工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置 SublimeText3 插件</title>
      <link href="/2018/05/05/%E9%85%8D%E7%BD%AESublimeText3%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/05/05/%E9%85%8D%E7%BD%AESublimeText3%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="1-SublimeText3-插件列表"><a href="#1-SublimeText3-插件列表" class="headerlink" title="1. SublimeText3 插件列表"></a>1. SublimeText3 插件列表</h2><blockquote><p><a href="https://packagecontrol.io/" target="_blank" rel="noopener">官方插件网站</a></p></blockquote><ul><li>Markdown编辑，可更换多种主题–<a href="https://packagecontrol.io/packages/MarkdownEditing" target="_blank" rel="noopener">Markdown​Editing</a></li><li>边栏主题切换，标签卡，状态栏等的设置，十分丰富–<a href="https://packagecontrol.io/packages/Boxy%20Theme" target="_blank" rel="noopener">Boxy Theme</a></li><li>边栏右键增强–<a href="https://packagecontrol.io/packages/SideBarEnhancements" target="_blank" rel="noopener">SideBar Enhancements</a><a id="more"></a></li><li>边栏图标高亮–<a href="https://packagecontrol.io/packages/A%20File%20Icon" target="_blank" rel="noopener">A File Icon</a></li><li>将当前文件编码转换，多种编码–<a href="https://packagecontrol.io/packages/ConvertToUTF8" target="_blank" rel="noopener">Convert​To​UTF8</a></li><li>括号高亮匹配–<a href="https://packagecontrol.io/packages/BracketHighlighter" target="_blank" rel="noopener">Bracket Highlighter</a></li><li>等号对齐–<a href="https://packagecontrol.io/packages/Alignment" target="_blank" rel="noopener">Alignment</a></li><li>Python 自动补全，函数跳转等–<a href="https://packagecontrol.io/packages/Anaconda" target="_blank" rel="noopener">Anaconda</a></li><li>运行 python–<a href="https://packagecontrol.io/packages/Conda" target="_blank" rel="noopener">Conda</a></li><li>编码检测–<a href="https://packagecontrol.io/packages/AutoPEP8" target="_blank" rel="noopener">AutoPEP8</a></li><li>多种语言的自动格式化–[CoolFormat(<a href="https://packagecontrol.io/packages/CoolFormat)]" target="_blank" rel="noopener">https://packagecontrol.io/packages/CoolFormat)]</a></li><li>任务标签–<a href="https://packagecontrol.io/packages/PlainTasks" target="_blank" rel="noopener">PlainTasks</a></li><li>python 的基于PEP8的自动格式化–<a href="https://packagecontrol.io/packages/Python%20PEP8%20Autoformat" target="_blank" rel="noopener">Python PEP8 Autoformat</a></li><li>代码检测–<a href="https://packagecontrol.io/packages/SublimeLinter" target="_blank" rel="noopener">SublimeLinter</a></li><li>代码检测 python<a href="https://packagecontrol.io/packages/SublimeLinter-flake8" target="_blank" rel="noopener">SublimLinter-flake8</a></li></ul><h2 id="2-用户设置"><a href="#2-用户设置" class="headerlink" title="2. 用户设置"></a>2. 用户设置</h2><ul><li>Sublime text -&gt; Preferences -&gt; Settings -&gt; User setting</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;trim_trailing_white_space_on_save&quot;: true,</span><br><span class="line">&quot;ensure_newline_at_eof_on_save&quot;: true,</span><br><span class="line">&quot;font_face&quot;: &quot;Microsoft YaHei Mono&quot;,</span><br><span class="line">&quot;disable_tab_abbreviations&quot;: true,</span><br><span class="line">&quot;translate_tabs_to_spaces&quot;: true,</span><br><span class="line">&quot;tab_size&quot;: 2,</span><br><span class="line">&quot;draw_minimap_border&quot;: true,</span><br><span class="line">&quot;save_on_focus_lost&quot;: true,</span><br><span class="line">&quot;highlight_line&quot;: true,</span><br><span class="line">&quot;word_wrap&quot;: &quot;true&quot;,</span><br><span class="line">&quot;fade_fold_buttons&quot;: false,</span><br><span class="line">&quot;bold_folder_labels&quot;: true,</span><br><span class="line">&quot;highlight_modified_tabs&quot;: true,</span><br><span class="line">&quot;default_line_ending&quot;: &quot;unix&quot;,</span><br><span class="line">&quot;auto_find_in_selection&quot;: true,</span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><blockquote><p><a href="https://janikarhunen.fi/pages/slides.html#slides" target="_blank" rel="noopener">https://janikarhunen.fi/pages/slides.html#slides</a><br><a href="https://www.zhihu.com/question/19976788/answer/48037047" target="_blank" rel="noopener">https://www.zhihu.com/question/19976788/answer/48037047</a><br><a href="https://www.zhihu.com/question/24736400" target="_blank" rel="noopener">https://www.zhihu.com/question/24736400</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hugo框架搭建博客</title>
      <link href="/2018/04/27/Hugo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/04/27/Hugo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<hr><blockquote><p>Update @ 2018-04-27 10:44:05:</p></blockquote><p>Hugo是一款静态网站搭建框架，用它搭建github page是个不错的选择。相比较于 Jekyll, Hugo 的本地调试环境更简洁。</p><h2 id="i-本地搭建步骤"><a href="#i-本地搭建步骤" class="headerlink" title="i. 本地搭建步骤"></a>i. 本地搭建步骤</h2><h3 id="1-本地环境搭建"><a href="#1-本地环境搭建" class="headerlink" title="1-本地环境搭建"></a>1-本地环境搭建</h3><p>在 Mac 下安装 Hugo 十分简洁，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install hugo</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-本地生成框架文件"><a href="#2-本地生成框架文件" class="headerlink" title="2-本地生成框架文件"></a>2-本地生成框架文件</h3><p>创建 blog 文件夹，将包含 hugo 框架的代码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new site blog</span><br></pre></td></tr></table></figure><h3 id="3-为博客选择主题"><a href="#3-为博客选择主题" class="headerlink" title="3-为博客选择主题"></a>3-为博客选择主题</h3><p>网站上有很多<a href="https://themes.gohugo.io/" target="_blank" rel="noopener">主题</a>，可以选择合适的下载再对它进行修改。这里选择的是 mainroad。下载主题后将压缩包解压后的文件夹放到以下文件夹下 <code>~/mygithub/blog/themes/mainroad</code>。 PS：需要对<code>~/mygithub/blog/\_config.toml</code>文件设置:  </p><ul><li>将主题设置为对应的主题文件夹的名称。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme = <span class="string">"mainroad"</span></span><br></pre></td></tr></table></figure><ul><li>设置baseurl = “127.0.0.1”； 本地调试Hugo默认打开的是127.0.0.1:1313,但需要设置baseurl,否则会出现网页主题渲染不正确的情况，事实上在部署到远程服务器上也需要指定 baseurl，后续会说明。</li><li>config.toml文件的说明</li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baseurl</span> = <span class="string">"127.0.0.1"</span> #设置本地调试的地址</span><br><span class="line"><span class="attr">title</span> = <span class="string">"forAllBright 的博客"</span> #博客的标题</span><br><span class="line"><span class="attr">languageCode</span> = <span class="string">"en-us"</span> #语言编码，目前没用到</span><br><span class="line"><span class="attr">paginate</span> = <span class="string">"4"</span> # 主页的每页的文章数量</span><br><span class="line"><span class="attr">theme</span> = <span class="string">"mainroad"</span> #主题</span><br><span class="line"><span class="attr">disqusShortname</span> = <span class="string">""</span> # 评论区显示的名称</span><br><span class="line"><span class="attr">googleAnalytics</span> = <span class="string">""</span> # 目前没有用到</span><br><span class="line"><span class="attr">defaultContentLanguage</span> = <span class="string">"en"</span> #默认的文章内容使用的语言</span><br><span class="line"><span class="section">[[menu.main]]</span> <span class="comment"># 设置菜单栏显示</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">"/"</span> #这个指的是 content 文件夹下</span><br><span class="line"><span class="attr">name</span> = <span class="string">"Home"</span></span><br><span class="line"><span class="attr">weight</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Author]</span> <span class="comment"># 每篇文章最下方显示的作者信息</span></span><br><span class="line">    name = "xxx </span><br><span class="line">    bio = "xxx"</span><br><span class="line">    avatar = "img/xxx.png"</span><br><span class="line"></span><br><span class="line"><span class="section">[Params]</span> <span class="comment">#  页面最上方显示的内容</span></span><br><span class="line">    subtitle = "xxxx" # Subtitle of your site</span><br><span class="line">    description = "" # Description of your site</span><br><span class="line">    opengraph = true</span><br><span class="line">    twitter_cards = false</span><br><span class="line">    readmore = false # Show "Read more" button in list if true</span><br><span class="line">    leftsidebar = false # Move sidebar to the left side if true</span><br><span class="line">    authorbox = true #是否显示文章下方的作者信息</span><br><span class="line">    post_navigation = true</span><br><span class="line">    postSections = ["post"]</span><br><span class="line">   <span class="comment">#--设置编程语言的字体--</span></span><br><span class="line">    googlefonts = ["Droid Sans", "Fira Mono"]</span><br><span class="line">    fontbody = 'Droid Sans'</span><br><span class="line">    fontcode = 'Fira Mono'</span><br><span class="line"><span class="comment">#--设置编程语言的字体--</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Params.widgets]</span> <span class="comment">#网页插件，标签，标签数，类别，增加搜索框，最近文章</span></span><br><span class="line">    search = false # Enable "Search" widget</span><br><span class="line">    recent_articles = true # Enable "Recent arcticles" widget</span><br><span class="line">    categories = true # Enable "Categories" widget</span><br><span class="line">    tags = true # Enable "Tags" widget</span><br><span class="line">    tags_counter = false # Enable counter for each tag in "Tags" widget (disabled by default)</span><br><span class="line">    <span class="comment"># social_github = "xxxxx" #github 账号名称</span></span><br></pre></td></tr></table></figure><h3 id="4-调试显示"><a href="#4-调试显示" class="headerlink" title="4-调试显示"></a>4-调试显示</h3><p>进入到 blog 文件夹下（不可以是它的子文件夹，否则报错），启动 hugo 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo server</span><br></pre></td></tr></table></figure><p>显示如下说明运行正常，在浏览器输入127.0.0.1:1313 可以看到网页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                   | EN</span><br><span class="line">+------------------+----+</span><br><span class="line">  Pages            | 21</span><br><span class="line">  Paginator pages  |  0</span><br><span class="line">  Non-page files   |  0</span><br><span class="line">  Static files     | 11</span><br><span class="line">  Processed images |  0</span><br><span class="line">  Aliases          |  8</span><br><span class="line">  Sitemaps         |  1</span><br><span class="line">  Cleaned          |  0</span><br><span class="line"></span><br><span class="line">Total in 50 ms</span><br><span class="line">Watching for changes in /Users/xxx/blog/&#123;content,data,layouts,static,themes&#125;</span><br><span class="line">Watching for config changes in /Users/xxx/blog/config.toml</span><br><span class="line">Serving pages from memory</span><br><span class="line">Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender</span><br><span class="line">Web Server is available at //localhost:1313/ (bind address 127.0.0.1)</span><br><span class="line">Press Ctrl+C to stop</span><br></pre></td></tr></table></figure><h2 id="ii-在-github-部署"><a href="#ii-在-github-部署" class="headerlink" title="ii. 在 github 部署"></a>ii. 在 github 部署</h2><h3 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1-创建远程仓库"></a>1-创建远程仓库</h3><p>在 github 上创建一个仓库，命名为 <code>xxx.github.io</code>，称为 <a href="https://help.github.com/articles/what-is-github-pages/" target="_blank" rel="noopener">github page</a>，是可以通过<code>https://xxx.github.io</code>直接在浏览器访问，并打开的是我们建好的网页。</p><h3 id="2-本地编译文件，打包"><a href="#2-本地编译文件，打包" class="headerlink" title="2-本地编译文件，打包"></a>2-本地编译文件，打包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo --theme=mainroad --buildDrafts --baseUrl=<span class="string">"https://xxx.github.io/"</span></span><br></pre></td></tr></table></figure><p>以上命令将生成一个 blog/public 文件夹，我们需要将 public 文件夹下的内容 push 到<code>https://xxx.github.io</code>。</p><h3 id="3-上传到-github-page"><a href="#3-上传到-github-page" class="headerlink" title="3-上传到 github page"></a>3-上传到 github page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@xxxxxx.git</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"init"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>等待几分钟后，刷新 <code>xxx.github.io</code> 页面将会显示与本地调试所显示一样的页面。</p><h2 id="iii-一些说明"><a href="#iii-一些说明" class="headerlink" title="iii. 一些说明"></a>iii. 一些说明</h2><h3 id="1-体会"><a href="#1-体会" class="headerlink" title="1-体会"></a>1-体会</h3><p>&emsp;&emsp; 搭建这个博客是想记录一些自己的体会和想法，这是首次接触网页前端源码，尝试在将博客网页自定义的过程中结合其他语言的特性来理解网页前端源码。令人惊喜的是前端的调试更能带来直观的感觉，在修改某个控件某个逻辑后会立刻展现在眼前。js，html，css 语言在编程上和其他编程语言有很多相似的特性，比如会用到属性，方法，会外部调用，会尽可能的通过配置文件来设置。有点感觉的某些项目的完成有共通的设计思想方法。</p><h3 id="2-代码高亮和代码字体设置"><a href="#2-代码高亮和代码字体设置" class="headerlink" title="2-代码高亮和代码字体设置"></a>2-代码高亮和代码字体设置</h3><p>&emsp;&emsp; 在本地调试的过程中，想将代码的字体显示换为另一种，这个卡了不少时间，最后是通过在本地网页的源码中找到的。一开始我尝试在<code>static.css</code>文件中修改 <code>code</code> 的字体，但是这并没有起到效果。那么这个设置应该是被其他地方的设置所覆盖了，而后google 到一半设置时会用 google 的开源字体代码来修饰，这在 <code>header.html</code>中设置，且需要在 <code>config.toml</code>配置。代码高亮与字体设置：</p><blockquote><p><code>header.html</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">hljs.initHighlightingOnLoad();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;&#123; range .Site.Params.googlefonts &#125;&#125;</span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> &#123;&#123; <span class="attr">printf</span> "<span class="attr">href</span>=<span class="string">\</span>"//<span class="attr">fonts.googleapis.com</span>/<span class="attr">css</span>?<span class="attr">family</span>=<span class="string">%s\</span>"" <span class="attr">.</span> | <span class="attr">safeHTMLAttr</span> &#125;&#125; <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">  &#123;&#123; end &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"> body &#123;</span></span><br><span class="line"><span class="undefined">     font-family: '&#123;&#123; .Site.Params.fontbody &#125;&#125;';</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"> code &#123;</span></span><br><span class="line"><span class="undefined">    font-family: '&#123;&#123; .Site.Params.fontcode &#125;&#125;'; </span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>config.toml</code></p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Params]</span></span><br><span class="line">    googlefonts = ["Droid Sans", "Fira Mono"]</span><br><span class="line">    fontbody = 'Droid Sans'</span><br><span class="line">    fontcode = 'Fira Mono'</span><br></pre></td></tr></table></figure><h3 id="3-结合mainroad主题对-Hugo-框架的理解"><a href="#3-结合mainroad主题对-Hugo-框架的理解" class="headerlink" title="3-结合mainroad主题对 Hugo 框架的理解"></a>3-结合mainroad主题对 Hugo 框架的理解</h3><p>1th：</p><ul><li><code>mainroad.theme</code>还是对 Hugo 的更标准的主题有了一些改动，比如 <code>bootstrap.theme</code>,标准主题更注重将对网页元素的配置放在 <code>config.toml</code> 中，且在核心的 html 文件中都会留有对配置文件的变量接口。</li><li>这个<a href="https://bookdown.org/yihui/blogdown/static-sites.html" target="_blank" rel="noopener">网站</a>讲述的不错。但是也是点到为止的讲了一下框架中一些文件的作用和互相的关系。</li><li>后续找时间看一下前端 css 和 js 是怎么协同工作的，了解一个主流的框架。</li></ul><h3 id="4-发布到-Netlify-网站"><a href="#4-发布到-Netlify-网站" class="headerlink" title="4-发布到 Netlify 网站"></a>4-发布到 Netlify 网站</h3><p>&emsp;&emsp; 看到<strong>Netlify</strong>的部署比 github page更方便（因为目前在用的方式是build 到 public 文件夹，然后对 puclic 文件夹 push，这有些繁琐，后来看到还会有种用submodule 的方式来处理这种需求的），需要将整个框架改动后的源码 push 到 github，然后通过 Netlify 取得与这个仓库的连接，设置好后就会自动的 build 到 public 然后部署其中的文件。<br>&emsp;&emsp; 注意的地方是：需要对 Netfify build 时的 hugo 版本设置为与本地调试一致，否则有可能 build fail 报错。<br><figure class="highlight plain"><figcaption><span>> Build environment variables, Edit, hit the plus sign, add key HUGO_VERSION with value 0.40.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title> </title>
      <link href="/2017/01/18/temp/"/>
      <url>/2017/01/18/temp/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category>   </category>
          
      </categories>
      
      
        <tags>
            
            <tag>   </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
